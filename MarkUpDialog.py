# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'VisualOptions.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
import SimpleFields
import GlobalVariables
from Function_class import Function_Gui
from otherFunctions import wrap

class area_mark_up(SimpleFields.AreaEntry):
    def __init__(self):
        super().__init__(edit=False)
        """if opening from event, it should add text to display field. but if opening from simple text field
        it should probably not do anything"""
        self.return_target = None
        """if doubleclicked on treeview, then update current text"""
        self.flag_update = False

    def keyPressEvent(self, event: QtGui.QKeyEvent):
        if self.return_target:
            if event.key() == QtCore.Qt.Key_Return:
                self.add_verse()
                return
            elif event.key() == QtCore.Qt.Key_Escape:
                self.clear_val()
                self.flag_update = False
        super().keyPressEvent(event)

    def add_verse(self):
        text = wrap(self.get_val(), length=150)
        if text:
            if self.flag_update:
                self.return_target.update_leaf(text)
                self.flag_update = False
            elif self.return_target.selected_element():
                """if already selected something, then insert above it"""
                self.return_target.insert_row([text])
            else:
                self.return_target.add_data(data=text)
            self.clear_val()
    def insert_text(self, text):
        """insert value where cursor is."""
        self.insertPlainText(text)
    def mark_text(self, beg, end):
        cursor = self.textCursor()
        new_text = beg + cursor.selectedText() + end
        self.insertPlainText(new_text)
        # print("Selection start: %d end: %d" %
        #       (cursor.selectionStart(), cursor.selectionEnd()))
# class CustomLabel(QtWidgets.QLabel):
#     # doubleClicked = pyqtSignal()
#     def __init__(self, master, label_text):
#         super().__init__(parent=master, text=label_text)
#         self.setAlignment(QtCore.Qt.AlignRight)
#
#     def update_label(self, new_label):
#         self.setText(new_label)
#
#     def change_position(self, position='C/L/R'):
#         if position == 'C':
#             self.setAlignment(QtCore.Qt.AlignCenter)
#         elif position == 'L':
#             self.setAlignment(QtCore.Qt.AlignLeft)
#         elif position == 'R':
#             self.setAlignment(QtCore.Qt.AlignRight)
#
#     def change_background_color(self):
#         self.setStyleSheet("background-color: red")
#     def clear_color(self):
#         self.setStyleSheet("")
#
# class UniqueView_scene(QtWidgets.QListView):
#     def __init__(self, master, field_title=None, class_connector=None, data_treeview=None):
#         super().__init__(parent=master)
#         self.connector_to_outside_complex_class = class_connector
#         self.type = 'multilist'
#         self.tree_model = QStandardItemModel()
#         self.setSelectionMode(QAbstractItemView.ExtendedSelection)
#         self.model_index = QtCore.QModelIndex()
#         self.setModel(self.tree_model)
#         self.setMaximumSize(160, 100)
#         self.setMinimumHeight(50)
#         self.setFixedHeight(20)
#         self.flag_edit = True
#         self.treeview_with_main_and_mod_data = data_treeview
#
#     def set_val(self, node=None, data=[]):
#         # example data ['file',{'folder ':['file']}]
#         if not node:
#             # node = self.rootnode
#             node = self.tree_model
#         else:
#             if isinstance(node, str):
#                 node = self.find_node(node)
#                 node = self.tree_model.itemFromIndex(node)
#         for values in data:
#             if isinstance(values, dict):
#                 for keys in values:
#                     parent_row = QStandardItem()
#                     parent_row.setText(keys)
#                     if self.flag_folders:
#                         parent_row.setEditable(False)
#                     node.appendRow(parent_row)
#                     self.add_data(parent_row, values[keys])
#             else:
#                 bottom_row = QStandardItem()
#                 bottom_row.setText(values)
#                 if not self.flag_child_editable:
#                     bottom_row.setEditable(False)
#                 node.appendRow(bottom_row)
#
#     def clear_val(self):
#         self.tree_model.clear()
#         self.setFixedHeight(20)
#     def add_data(self, node=None, data=[]):
#         # example data ['file',{'folder ':['file']}]
#         if not node:
#             # node = self.rootnode
#             node = self.tree_model
#         else:
#             if isinstance(node, str):
#                 node = self.find_node(node)
#                 node = self.tree_model.itemFromIndex(node)
#         if isinstance(data, list):
#             for values in data:
#                 self.add_data(node, values)
#         elif isinstance(data, dict):
#             for key in data:
#                 parent_row = QStandardItem()
#                 parent_row.setText(key)
#                 parent_row.setEditable(False)
#                 node.appendRow(parent_row)
#                 self.add_data_to_display(parent_row, data[key])
#         else:
#             """if data is just string"""
#             bottom_row = QStandardItem()
#             bottom_row.setText(data)
#             bottom_row.setEditable(False)
#             node.appendRow(bottom_row)
#             if self.height() < 100:
#                 self.setFixedHeight(self.height() + 20)
#         # if not node:
#         #     # node = self.rootnode
#         #     node = self.tree_model
#         # else:
#         #     if isinstance(node, str):
#         #         node = self.find_node(node)
#         #         node = self.tree_model.itemFromIndex(node)
#         # for values in data:
#         #     if isinstance(values, dict):
#         #         for keys in values:
#         #             parent_row = QStandardItem()
#         #             parent_row.setText(keys)
#         #             if self.flag_folders:
#         #                 parent_row.setEditable(False)
#         #             node.appendRow(parent_row)
#         #             self.add_data(parent_row, values[keys])
#         #     else:
#         #         bottom_row = QStandardItem()
#         #         bottom_row.setText(values)
#         #         bottom_row.setEditable(False)
#         #         node.appendRow(bottom_row)
#         if self.flag_edit:
#             GlobalVariables.Glob_Var.edited_field()
#     def keyPressEvent(self, event: QtGui.QKeyEvent):
#         if event.key() == Qt.Key_Delete:
#             # self.delete_leaf()
#             self.delete()
#     def delete(self):
#         selected_items_idx = self.selectedIndexes()
#         selected_items = []
#         for idx in selected_items_idx:
#             selected_items.append(self.tree_model.itemFromIndex(idx))
#         for items in selected_items:
#             item = self.tree_model.indexFromItem(items)
#             self.tree_model.removeRow(item.row(), item.parent())
#             if self.height() > 20:
#                 self.setFixedHeight(self.height() - 20)
#     def destroy(self):
#         for idx in range(self.custom_layout.count()):
#             temp = self.custom_layout.takeAt(0)
#             self.custom_layout.removeWidget(temp.widget())
#             temp.widget().deleteLater()
#     def get_data(self, parent_index=None, root_list=None):
#         """stuff are in a list, where file should be strings, while folders should be dict
#         should return something like [row0, row1, {row2:[row20, row21]},[row3column0, row3column1]}"""
#         if parent_index:
#             row_range = self.tree_model.rowCount(parent_index)
#             col_range = self.tree_model.columnCount(parent_index)
#         else:
#             row_range = self.tree_model.rowCount()
#             col_range = self.tree_model.columnCount()
#         current_row_folder = {}
#         rows_list = []
#         ix = None
#         for i in range(row_range):
#             cols_list = []
#             for ii in range(col_range):
#                 if parent_index:
#                     row_index = self.tree_model.index(i, ii, parent_index)
#                 else:
#                     row_index = self.tree_model.index(i, ii)
#                 self.get_data(row_index, cols_list)
#             # here i would have to check if other columns are empty, if yes, turn cols_list into a string
#             for vals in cols_list:
#                 if not vals:
#                     cols_list.remove(vals)
#             if len(cols_list) == 1:
#                 rows_list.append(cols_list[0])
#             else:
#                 rows_list.append(cols_list)
#             if parent_index:
#                 current_row_folder[parent_index.data()] = rows_list
#         if current_row_folder:
#             root_list.append(current_row_folder)
#         else:
#             if parent_index:
#                 root_list.append(parent_index.data())
#             else:
#                 return rows_list
#     def focusInEvent(self, event):
#         """when clicked on widget, connect it to main multilist, where it filters appropiate items to select and add"""
#         if self.connector_to_outside_complex_class:
#             # GlobalVariables.Glob_Var.main_game_field.connect_multilist(self.connector_to_outside_complex_class)
#             self.treeview_with_main_and_mod_data.connect_multilist(self.connector_to_outside_complex_class)
#         else:
#             # GlobalVariables.Glob_Var.main_game_field.disconnect_multilist()
#             self.treeview_with_main_and_mod_data.disconnect_multilist()
#         super().focusInEvent(event)
# class SimpleEntry_scene(QtWidgets.QLineEdit):
#     def __init__(self, master_widget, field_name=None, field_data=None, template_name=None, class_connector=None
#                  , edit=True, main_data_treeview=None, label_pos='H'):
#         super().__init__(parent=master_widget)
#         if label_pos == 'H':
#             self.custom_layout = QtWidgets.QHBoxLayout()
#             self.custom_layout.setAlignment(QtCore.Qt.AlignCenter)
#         else:
#             self.custom_layout = QtWidgets.QVBoxLayout()
#             self.custom_layout.setAlignment(QtCore.Qt.AlignCenter)
#         if field_name:
#             # if len(field_name) < 2:
#             if isinstance(field_name, int):
#                 field_name = 'Amount'
#             self.label_custom = CustomLabel(master_widget, field_name)
#             self.custom_layout.addWidget(self.label_custom)
#         self.custom_layout.addWidget(self)
#         self.template_name = template_name
#         self.title = field_name
#         self.type = 'text'
#         self.old_value = ''
#         self.default_value = ''
#         self.addition = False
#         self.setMinimumWidth(70)
#         self.setMaximumWidth(220)
#         self.row_size = 1
#         """this is for multilist display. in case multilist class accepts only 1 value, no points in making entire tree.
#         so intead, just make simple text field, which is created in another class"""
#         self.connector_to_outside_complex_class = class_connector
#         self.treeview_with_main_and_mod_data = main_data_treeview
#         if field_data:
#             if 'tooltip' in field_data:
#                 self.setToolTip(field_data['tooltip'])
#             if 'default' in field_data:
#                 self.default_value = field_data['default']
#             if 'options' in field_data:
#                 if 'addition' in field_data['options']:
#                     self.addition = True
#
#         # self.temp_master = master
#         self.shortcuts = []
#         self.setObjectName('entry')
#         if edit:
#             self.field_modified_check()
#
#     def clear_val(self):
#         self.clear()
#
#     def cancel(self):
#         self.setReadOnly(True)
#         return
#
#     def get_val(self, temp_dict_container=None):
#         return_val = self.text()
#         if return_val == "":
#             return_val = self.default_value
#         if temp_dict_container is not None:
#             temp_dict_container[self.title] = return_val
#         else:
#             return return_val
#
#     def set_val(self, new_value):
#         self.setText(new_value)
#
#     def set_up_widget(self, outside_layout, insert_for_optional=False):
#         """insert for optional is mostly for optional fields to insert widget before last stretch"""
#         if insert_for_optional:
#             outside_layout.insertLayout(outside_layout.count()-1, self.custom_layout)
#             # outside_layout.insertWidget(outside_layout.count()-1, self.custom_layout)
#         else:
#             outside_layout.addLayout(self.custom_layout)
#
#     # def set_up_shortcut(self, sequence, function):
#     #     shortcut = QtWidgets.QShortcut(QtGui.QKeySequence(sequence), self)
#     #     shortcut.activated.connect(function)
#     #     self.shortcuts.append(shortcut)
#
#     # if field is in complex class and should allow access to main items, connector will be created. it should
#     #  be passed to main game field. If fields does not have access, connector is NONE, so should disconnect main field
#     def focusInEvent(self, event):
#         if self.connector_to_outside_complex_class and self.treeview_with_main_and_mod_data:
#             # GlobalVariables.Glob_Var.main_game_field.connect_multilist(self.connector_to_outside_complex_class)
#             self.treeview_with_main_and_mod_data.connect_multilist(self.connector_to_outside_complex_class)
#         else:
#             # GlobalVariables.Glob_Var.main_game_field.disconnect_multilist()
#             if self.treeview_with_main_and_mod_data:
#                 self.treeview_with_main_and_mod_data.disconnect_multilist()
#         super().focusInEvent(event)
#
#     def field_modified_check(self):
#         self.textChanged.connect(GlobalVariables.Glob_Var.edited_field)
#
#     def function_on_modify(self, function=None):
#         self.textChanged.connect(function)
#
#     def destroy(self):
#         for idx in range(self.custom_layout.count()):
#             temp = self.custom_layout.takeAt(0)
#             self.custom_layout.removeWidget(temp.widget())
#             temp.widget().deleteLater()
#     def center(self):
#         self.setAlignment(QtCore.Qt.AlignCenter)
#     # def focusOutEvent(self, event):
#     #     print('event-focus-out:', self.objectName())
#     #     super().focusOutEvent(event)
# class MultiListDisplay_scene:
#     """there are 3 types of data here.
#     single item - only 1 item allowed, so it could be an input field, where you can type text to autosearch for
#      available values from main multilist, also limited to type of items to seachs
#     several items - this allows several items with no duplication. will be a treeview and maybe add something like above
#     multiple items - several with duplicates."""
#     def __init__(self, master=None, field_name=None,
#                  field_data=None, template_name=None, main_data_treeview=None):
#         self.title = field_name
#         self.type = 'multilist'
#         self.template_name = template_name
#         self.label_custom = CustomLabel(master, field_name)
#         # self.label_custom = custom_button(master, field_name)
#         self.addition = False
#         self.row_size = 4
#         # field_data = {'options':['unique'], 'choices':['Items']}
#         if 'options' in field_data:
#             if 'single_item' in field_data['options']:
#                 self.version = 'single'
#                 self.row_size = 1
#             elif 'unique' in field_data['options']:
#                 self.version = 'unique'
#             else:
#                 self.version = 'multi_item'
#             if 'addition' in field_data['options']:
#                 self.addition = True
#         if 'tooltip' in field_data:
#             self.label_custom.setToolTip(field_data['tooltip'])
#         # self.label_custom.change_position('center')
#         # self.label_custom.button_transform()
#         self.field_frame = master
#         self.selection_type = ''
#         if 'choices' in field_data:
#             for choice in field_data['choices']:
#                 if 'Items' in choice:
#                     self.selection_type += 'Items'
#                 elif 'Skills' in choice:
#                     self.selection_type += 'Skills'
#                 elif 'Perks' in choice:
#                     self.selection_type += 'Perks'
#                 elif 'Monsters' in choice:
#                     self.selection_type += 'Monsters'
#                 elif 'Fetishes' in choice:
#                     self.selection_type += 'Fetishes Addictions'
#                 else:
#                     self.selection_type += choice
#                     # self.selection_type += field_data['choices'][0]
#         """
#         unique - can add multiple items, cannot duplicate
#         multi_item - items can be duplicated
#         single_item - can only select 1 item
#         """
#         self.custom_layout = QtWidgets.QVBoxLayout()
#         if self.version == 'single':
#             self.final_data = SimpleEntry(master, None, class_connector=self, main_data_treeview=main_data_treeview)
#             self.label_custom.change_position('R')
#             self.custom_layout = QtWidgets.QHBoxLayout()
#             self.custom_layout.setAlignment(QtCore.Qt.AlignCenter)
#         elif self.version == 'unique':
#             # self.final_data = QtWidgets.QListWidget(parent=master)
#             self.final_data = UniqueView(master=master, class_connector=self, data_treeview=main_data_treeview)
#             self.label_custom.change_position('center')
#         else:
#             self.final_data = UniqueView(master=master, class_connector=self, data_treeview=main_data_treeview)
#             # self.final_data = ElementsList(master, field_name, class_connector=self)
#             self.label_custom.change_position('center')
#         self.custom_layout.addWidget(self.label_custom)
#         self.custom_layout.addWidget(self.final_data)
#         self.custom_layout.addStretch(1)
#
#             # self.set_row_size(6)
#             # self.data_tree = ElementsList(self, 3, 0, 'Double Click to Edit', colspan=3, treeview_height=3)
#             # self.data_tree.treeview.configure(selectmode='extended')
#             # self.data_tree.treeview.bind("<Double-Button-1>", self.on_double_click_edit_field)
#             # self.data_tree.treeview.unbind("<Delete>")
#             # self.data_tree.treeview.unbind("<Control_L>")
#         # self.label_custom.doubleClicked.connect(self.edit_value)
#         # self.label_custom.doubleClicked.connect(self.edit_value)
#         # self.label_custom.clicked.connect(self.edit_value)
#
#     def set_val(self, values):
#         if self.version == 'single':
#             self.final_data.set_val(values)
#         else:
#             if self.version == 'unique':
#                 if isinstance(values, str):
#                     values = [values]
#                 current_count = self.final_data.tree_model.rowCount()
#                 current_values = []
#                 for idx in range(current_count):
#                     item = self.final_data.tree_model.item(idx)
#                     current_values.append(item.text())
#                 for value in values:
#                     if value not in current_values:
#                         # self.final_data.addItem(value)
#                         self.final_data.add_data('',[value])
#             #             TODO maybe add warning?
#             else:
#                 self.final_data.add_data(data=[values])
#     def get_val(self, temp_dict_container=None):
#         # if self.version == 'single':
#         #     temp = self.var.get()
#         #     if 'CLICK' in temp:
#         #         temp = ''
#         # else:
#         #     temp = []
#         #     all_vals = self.data_tree.treeview.get_children()
#         #     for value in all_vals:
#         #         temp.append(self.data_tree.treeview.item(value)['text'])
#         #     # this might be important if there is a problem with values returned somewhere
#         #     # if len(temp) == 0:
#         #     #     temp.append('')
#         if self.version == 'single':
#             return_data = self.final_data.get_val()
#         elif self.version == 'unique':
#             return_data = []
#             current_count = self.final_data.count()
#             for idx in range(current_count):
#                 item = self.final_data.item(idx)
#                 return_data.append(item.text())
#         else:
#             return_data = self.final_data.get_data()
#         if temp_dict_container is not None:
#             temp_dict_container[self.title] = return_data
#         else:
#             return return_data
#
#     def clear_val(self):
#         if self.version == 'unique':
#             self.final_data.clear()
#         else:
#             self.final_data.clear_val()
#     def hide(self):
#         self.label_custom.hide()
#         self.final_data.hide()
#     def show(self):
#         self.final_data.show()
#         if self.label_custom.text():
#             self.label_custom.show()
#     def edit_value(self):
#         # this is for editing in new window
#         print('test edit value miltilist)')
#         item_win = QtWidgets.QDialog(parent=self.field_frame)
#         item_visual = MainGameItemsInNewWindow()
#         item_visual.setupUi(Dialog=item_win)
#         item_win.show()
#     def destroy(self):
#         # self.custom_layout.deleteLater()
#         for idx in range(self.custom_layout.count()):
#             temp = self.custom_layout.takeAt(0)
#             self.custom_layout.removeWidget(temp.widget())
#             if temp:
#                 if not isinstance(temp, QtWidgets.QSpacerItem):
#                     temp.widget().deleteLater()
#         self.custom_layout.deleteLater()
#     def set_up_widget(self, outside_layout, insert_for_options=False):
#         if insert_for_options:
#             outside_layout.insertLayout(outside_layout.count() - 1, self.custom_layout)
#         else:
#             outside_layout.addLayout(self.custom_layout)
#         outside_layout.setAlignment(self.custom_layout,QtCore.Qt.AlignCenter)


class MarkUp_Window(QtWidgets.QWidget):
    def __init__(self, target_field=None, scenes_flag=None, data_for_functions=None, current_scene_list=None,
                 scene_data=None):
        super().__init__()
        if current_scene_list:
            self.current_scenes = current_scene_list
            self.functions_list = list(GlobalVariables.Glob_Var.functions_data.keys())
        else:
            self.current_scenes = None
        """target field - either treeview for scenes or text field for some fields that allow markups
        scenes_flag - if textfied is target, no need to display treeview for scenes"""
        self.setWindowTitle('Events')
        # Dialog.resize(310, 299)
        # self.widget.setGeometry(QtCore.QRect(0, 10, 301, 281))
        self.setObjectName("FunctionWin")
        self.resize(900, 500)

        self.v_main_layout = QtWidgets.QVBoxLayout(self)
        self.v_main_layout.setContentsMargins(0, 0, 0, 0)
        self.v_main_layout.setObjectName("mainLayout")
        self.setLayout(self.v_main_layout)


        v_layout_buttons = QtWidgets.QHBoxLayout()
        v_layout_buttons.setObjectName("button_layout")
        self.mark_up_buttons_background_player = QtWidgets.QWidget()
        self.mark_up_buttons_background_text = QtWidgets.QWidget()
        # v_layout_buttons.addWidget(self.mark_up_buttons_background_player)
        # v_layout_buttons.addWidget(self.mark_up_buttons_background_text)
        self.prepare_markup_buttons()
        """all the buttons for markups here"""
        # placeholder_buttons = SimpleFields.CustomButton(self, 'placeholder width')
        # # placeholder_buttons.clicked.connect(lambda: self.change_size(1))
        # placeholder_buttons.clicked.connect(self.test)
        # placeholder_buttons2 = SimpleFields.CustomButton(self, 'placeholder2 heigh')
        # placeholder_buttons2.clicked.connect(lambda: self.change_size(2))
        # h_layout_buttons.addWidget(placeholder_buttons)
        # h_layout_buttons.addWidget(placeholder_buttons2)
        # self.v_main_layout.addLayout(v_layout_buttons)
        self.v_main_layout.addWidget(self.mark_up_buttons_background_player)
        self.v_main_layout.addWidget(self.mark_up_buttons_background_text)

        """main data. Area text for input and treeview for display on the left
        checkboxes, treeview for functions and functions creation on right"""
        """first, vertical, contains area text and treeview"""
        # v_layout_main_input = QtWidgets.QVBoxLayout()
        # v_layout_main_input.setObjectName("main_input_layout")
        # self.text_test = SimpleFields.SimpleEntry(self)
        # self.text_test.set_up_widget(self.v_main_layout)
        # self.area_input = SimpleFields.AreaEntry(self, edit=False)
        self.area_input = area_mark_up()
        self.area_input.setMaximumSize(800, 100)
        self.area_input.set_up_widget(self.v_main_layout)
        """now, display data on the left and on the right, checkboxes and functions gui"""
        """on the left is only treeview for data from input.
        on the right is top - 2 checkboxes, then below area with explanation, treeview with functions and 2 buttons"""
        h_layout_display_f_gui = QtWidgets.QHBoxLayout()

        # v_layout_left_side = QtWidgets.QVBoxLayout()
        # h_layout_display_f_gui.addLayout(v_layout_left_side)
        if scenes_flag:
            """first vertical to put button at the top"""
            v_layout_display = QtWidgets.QVBoxLayout()
            self.button_display_scenes = SimpleFields.CustomButton(None, 'Scenes')
            self.button_display_scenes.setMaximumWidth(100)
            self.button_display_scenes.clicked.connect(self.display_scene_list)
            v_layout_display.addWidget(self.button_display_scenes)
            self.button_display_scenes_data = SimpleFields.CustomButton(None, 'Data')
            self.button_display_scenes_data.setMaximumWidth(100)
            self.button_display_scenes_data.clicked.connect(self.switch_to_data)
            self.flag_data = False
            v_layout_display.addWidget(self.button_display_scenes_data)
            """now add horizontal, to put scene display and text display next to each other.
            Also, so I dont have to resize them each time, put it on a background widget"""
            h_layout_display = QtWidgets.QHBoxLayout()
            """look up for scene list for current event"""
            self.display_scene_widget_background = QtWidgets.QWidget()
            # self.display_scene_widget_background.setMaximumWidth(400)
            self.display_scene_widget_background.setFixedWidth(400)
            # sp = self.display_scene_widget_background.sizePolicy()
            # sp.setHorizontalPolicy(QtWidgets.QSizePolicy.Expanding)
            # self.display_scene_widget_background.setSizePolicy(sp)
            self.display_scene_widget_background.setLayout(h_layout_display)
            v_layout_display.addWidget(self.display_scene_widget_background)
            # v_layout_display.addLayout(h_layout_display)
            self.scene_list = SimpleFields.ElementsList(self, search_field=True)
            temp = {}
            if self.current_scenes:
                for event_type in self.current_scenes:
                    templist = []
                    for scene_name in self.current_scenes[event_type]:
                        templist.append(scene_name)
                    temp[event_type] = templist
                self.scene_list.add_data(temp)
            self.scene_list.set_up_widget(h_layout_display)
            self.scene_list.hide()
            self.scene_list.doubleClicked.connect(self.load_scene_to_display)
            """hidden setup of basic scene data"""
            v_layout_display_scene_data = QtWidgets.QVBoxLayout()
            self.scene_data_widget_background = QtWidgets.QWidget()
            self.scene_data_widget_background.setLayout(v_layout_display_scene_data)
            h_layout_display.addWidget(self.scene_data_widget_background)
            """first, clean it to make it easier"""
            self.data_fields = []
            temp_fields = {}
            """this temp mainfield is created later as part of function gui field.
             also, needs to show it, as normally is hidden"""
            temp_mainfield_data = None
            self.flag_main_data = False
            # TODO problem is with multilist, they should connect to main treeview, but only main treeview here is created later as part of functions gui
            if scene_data:
                for data_field in scene_data:
                    for field in scene_data[data_field]:
                        if field != 'theScene':
                            temp_fields[field] = scene_data[data_field][field]
                for fieldname in temp_fields:
                    """now, same as in custome fields, create appropiate fields"""
                    if temp_fields[fieldname]["type"] == "text":
                        tempfield = SimpleFields.SimpleEntry(master_widget=self.scene_data_widget_background, field_name=fieldname,
                                                             field_data=temp_fields[fieldname],
                                                             main_data_treeview=temp_mainfield_data, label_pos='V')
                    elif temp_fields[fieldname]["type"] == "int":
                        tempfield = SimpleFields.NumericEntry(master=self.scene_data_widget_background, wid=4, field_name=fieldname,
                                                              field_data=temp_fields[fieldname])
                    elif temp_fields[fieldname]["type"] == "singlelist":
                        field_optionbox = SimpleFields.SingleList(self.scene_data_widget_background, fieldname, temp_fields[fieldname])
                        # field_optionbox.configure(takefocus=1)
                        tempfield = field_optionbox
                    elif temp_fields[fieldname]["type"] == "filePath":
                        tempfield = SimpleFields.FileField(self.scene_data_widget_background, fieldname, field_data=temp_fields[fieldname])
                    elif temp_fields[fieldname]["type"] == 'area':
                        tempfield = SimpleFields.AreaEntry(self.scene_data_widget_background, fieldname)
                    elif temp_fields[fieldname]["type"] == 'multilist':
                        tempfield = SimpleFields.MultiListDisplay(self.scene_data_widget_background, fieldname, temp_fields[fieldname],
                                                                  main_data_treeview=temp_mainfield_data)
                        self.flag_main_data = True
                    self.data_fields.append(tempfield)
                    tempfield.set_up_widget(v_layout_display_scene_data)
                    # v_layout_display_scene_data.addWidget(tempfield)
            self.scene_data_widget_background.hide()
            v_layout_display_scene_data.addStretch(1)
            """here is display data. is where iines and functions for scene are displayed and can be modified"""
            self.display_data = SimpleFields.ElementsList(self, "Event text")
            self.display_data.setMaximumSize(600, 350)
            self.display_data.parent_tag = 'function'
            # self.display_data.setMinimumSize(200, 300)
            self.display_data.set_up_widget(h_layout_display)
            self.display_data.doubleClicked.connect(self.update_row)
            h_layout_display_f_gui.addLayout(v_layout_display)
        else:
            self.scene_list = None
            self.display_data = None
            self.scene_button = None

        v_layout_right_side = QtWidgets.QVBoxLayout()
        h_layout_display_f_gui.addLayout(v_layout_right_side)
        """layout for functions field creations, already added"""
        self.v_layout_function_fields = QtWidgets.QVBoxLayout()
        self.v_layout_function_fields.setObjectName('function_fields_layout')
        h_layout_display_f_gui.addLayout(self.v_layout_function_fields)
        h_layout_display_f_gui.addStretch(1)
        # """2 checkboxes, determine how to add functions"""
        # h_lay_checkboxes = QtWidgets.QHBoxLayout()
        # self.checkbox_text = SimpleFields.CheckBox(self, 'TEXT', 't')
        # self.checkbox_text.set_up_widget(h_lay_checkboxes)
        # self.checkbox_event = SimpleFields.CheckBox(self, 'EVENT', 'e')
        # self.checkbox_event.set_up_widget(h_lay_checkboxes)
        # self.button_group = QtWidgets.QButtonGroup()
        # self.button_group.addButton(self.checkbox_text)
        # self.button_group.addButton(self.checkbox_event)
        # self.button_group.buttonToggled.connect(self.on_checkbox_toggled)
        # """flag function will be list. first its a 0/1, second, target field"""
        # self.flag_function_target_type = []
        # if not scenes_flag:
        #     self.checkbox_event.setEnabled(False)
        #     self.checkbox_text.set_val(True)
        #     self.checkbox_event.setEnabled(False)
        # h_lay_checkboxes.setAlignment(QtCore.Qt.AlignCenter)
        # v_layout_right_side.addLayout(h_lay_checkboxes)
        """functions gui"""
        # TODO function gui for now

        if scenes_flag:
            config_list = [1, self.area_input, self.display_data]
        else:
            config_list = [0, self.area_input, None]
        self.functions = Function_Gui(None, None, self, fields_lay=self.v_layout_function_fields,
                                      adding_config=config_list, scene_list=current_scene_list)
        self.functions.set_up_widget(v_layout_right_side)
        temp_mainfield_data = self.functions.treeview_main_game_items

        self.v_layout_function_fields.addStretch(1)
        # """second, 2 checkboxes for adding function to text of event and now the hard part, whole functionality"""
        # h_lay_functions_main = QtWidgets.QHBoxLayout()
        # h_lay_functions_main.setObjectName('functions_layout_main')
        # v_layout_function_window = QtWidgets.QVBoxLayout()
        # v_layout_function_window.setObjectName('function_window_layout')
        # h_lay_checkboxes = QtWidgets.QHBoxLayout()
        # self.checkbox_text = SimpleFields.CheckBox(self, 'text', 't')
        # self.checkbox_text.set_up_widget(h_lay_checkboxes)
        # self.checkbox_event = SimpleFields.CheckBox(self, 'event', 'e')
        # self.checkbox_event.set_up_widget(h_lay_checkboxes)
        # self.flag_function_target_type = None
        # v_layout_function_window.addLayout(h_lay_checkboxes)
        self.v_main_layout.addLayout(h_layout_display_f_gui)
        # TODO fix save button, save data into scene list
        but_save = SimpleFields.CustomButton(None, 'SAVE')
        but_save.setMaximumWidth(100)
        but_save.clicked.connect(self.save_data)
        self.v_main_layout.addWidget(but_save)
        #
        # v_layout_function_fields = QtWidgets.QVBoxLayout()
        # # self.functions = Function_Gui(self.flag_function_target_type, None, fields_lay=v_layout_function_fields)
        # # self.functions.set_up_widget(v_layout_function_window)
        #
        # h_lay_functions_main.addLayout(v_layout_function_window)
        # h_lay_functions_main.addLayout(v_layout_function_fields)

        # self.buttonBox = QtWidgets.QDialogButtonBox(self)
        # self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
        # self.buttonBox.setStandardButtons(QtWidgets.QDialogButtonBox.Cancel | QtWidgets.QDialogButtonBox.Ok)
        # self.buttonBox.setObjectName("buttonBox")
        # self.v_main_layout.addWidget(self.buttonBox)
        #
        # self.retranslateUi(Dialog)
        # self.buttonBox.accepted.connect(Dialog.accept)
        # self.buttonBox.rejected.connect(Dialog.reject)
        # QtCore.QMetaObject.connectSlotsByName(Dialog)
        if scenes_flag:
            self.area_input.return_target = self.display_data

    def prepare_markup_buttons(self):
        v_lay_main = QtWidgets.QVBoxLayout()
        label_chara = SimpleFields.CustomLabel(None, 'CHARACTER')
        label_chara.change_position('C')
        v_lay_main.addWidget(label_chara)

        h_lay_first = QtWidgets.QHBoxLayout()
        self.l_player_name = SimpleFields.SingleList(edit=False)
        self.l_player_name.reload_options(['Player Name', 'normal', 'shout', 'initials'])
        self.l_player_name.currentTextChanged.connect(self.player_name)
        h_lay_first.addWidget(self.l_player_name)

        b_player_money = SimpleFields.CustomButton(None, 'Player Money')
        b_player_money.clicked.connect(lambda: self.area_input.insert_text('{PlayerMoney}'))
        h_lay_first.addWidget(b_player_money)
        b_player_progress = SimpleFields.CustomButton(None, 'Player Progress')
        b_player_progress.clicked.connect(lambda: self.area_input.insert_text('{ProgressDisplay}'))
        h_lay_first.addWidget(b_player_progress)
        h_lay_first.addStretch(1)
        b_player_choice = SimpleFields.CustomButton(None, 'Player Choice')
        b_player_choice.clicked.connect(lambda: self.area_input.insert_text('{DisplayPlayerChoice}'))
        h_lay_first.addWidget(b_player_choice, alignment=QtCore.Qt.AlignRight)
        b_player_orgasm = SimpleFields.CustomButton(None, 'Player Orgasm')
        b_player_orgasm.setToolTip('displays the orgasm line for the player or monster respectively.\n'
                                   ' To be used with OnPlayerOrgasm and OnOrgasm lineTriggers utilizing events respectively. \n'
                                   'If using it in a loop, use the EmptySpiritCounter function after the line \n'
                                   'to empty out how much spirit is counted')
        b_player_orgasm.clicked.connect(lambda: self.area_input.insert_text('{PlayerOrgasmLine}'))
        h_lay_first.addWidget(b_player_orgasm, alignment=QtCore.Qt.AlignRight)
        v_lay_main.addLayout(h_lay_first)

        h_lay_second = QtWidgets.QHBoxLayout()
        self.l_damage_target = SimpleFields.SingleList(edit=False)
        self.l_damage_target.reload_options(['Damage Target', 'player', 'enemy', 'final'])
        self.l_damage_target.currentTextChanged.connect(self.damage_target)
        h_lay_second.addWidget(self.l_damage_target)

        self.l_mark_1 = SimpleFields.SingleList(edit=False)
        self.l_mark_1.reload_options(['Attacker', 'YouOrMonsterName', 'HeOrShe', 'HisOrHer', 'HimOrHer'])
        self.l_mark_1.currentTextChanged.connect(lambda: self.mark(self.l_mark_1))
        h_lay_second.addWidget(self.l_mark_1)
        self.l_mark_2 = SimpleFields.SingleList(edit=False)
        # self.l_mark_2.reload_options(['ATarget', 'YouOrMonsterName', 'HeOrShe', 'HisOrHer', 'HimOrHer'])
        self.l_mark_2.set_val(['Target', 'YouOrMonsterName', 'HeOrShe', 'HisOrHer', 'HimOrHer'], sort=False)
        self.l_mark_2.currentTextChanged.connect(lambda: self.mark(self.l_mark_2))
        h_lay_second.addWidget(self.l_mark_2)
        h_lay_second.addStretch(1)
        b_m_choice = SimpleFields.CustomButton(None, 'Monster Choice')
        b_m_choice.clicked.connect(lambda: self.area_input.insert_text('{DisplayMonsterChoice}'))
        h_lay_second.addWidget(b_m_choice, alignment=QtCore.Qt.AlignRight)
        b_m_orgasm = SimpleFields.CustomButton(None, 'Monster Orgasm')
        b_m_orgasm.clicked.connect(lambda: self.area_input.insert_text('{MonsterOrgasmLine}'))
        h_lay_second.addWidget(b_m_orgasm, alignment=QtCore.Qt.AlignRight)
        v_lay_main.addLayout(h_lay_second)

        """second part"""

        label_text = SimpleFields.CustomLabel(None, 'TEXT')
        label_text.change_position('C')
        v_lay_main.addWidget(label_text)

        h_lay_3 = QtWidgets.QHBoxLayout()


        b_colour_text = SimpleFields.CustomButton(None, 'C TEXT')
        h_lay_3.addWidget(b_colour_text)
        b_colour_example1 = SimpleFields.CustomButton(None, 'EXAMPLE')
        h_lay_3.addWidget(b_colour_example1)
        b_colour_text.clicked.connect(lambda: self.show_color_picker(b_colour_example1))
        b_colour_example1.clicked.connect(lambda: self.colour_text(b_colour_example1))
        b_colour_outline = SimpleFields.CustomButton(None, 'C OUTLINE')
        h_lay_3.addWidget(b_colour_outline)
        b_colour_example2 = SimpleFields.CustomButton(None, 'EXAMPLE')
        h_lay_3.addWidget(b_colour_example2)
        b_colour_outline.clicked.connect(lambda: self.show_color_picker(b_colour_example2))
        b_colour_example2.clicked.connect(lambda: self.colour_text(b_colour_example2))


        b_delay_input = SimpleFields.CustomButton(None, 'Delay until input')
        b_delay_input.setToolTip('will delay the displayed text till user input is given to signal it to continue.\n'
                                 ' It can be given an integer value via {w=int} to make it wait the given\n'
                                 ' integer number in seconds, though it can continue early through user input\n'
                                 ' before the given time has elapsed.')
        b_delay_input.clicked.connect(lambda: self.area_input.insert_text('{w}'))
        h_lay_3.addWidget(b_delay_input)
        b_delay_nline = SimpleFields.CustomButton(None, 'Delay until new line')
        b_delay_nline.setToolTip('same as input but inserts line breaks for every time it is called')
        b_delay_nline.clicked.connect(lambda: self.area_input.insert_text('{}'))
        h_lay_3.addWidget(b_delay_nline)
        b_get_over = SimpleFields.CustomButton(None, 'Get over here')
        b_get_over.setToolTip('placed anywhere in the string causes the displayed text to instantly move towards the markup declaration. \n'
                              'Given MGD by default has all text display instantly, this typically won’t be too useful unless combined with the {cps}')
        b_get_over.clicked.connect(lambda: self.area_input.insert_text('{nw}'))
        h_lay_3.addWidget(b_get_over)
        v_lay_main.addLayout(h_lay_3)

        h_lay_4 = QtWidgets.QHBoxLayout()
        b_text_speed = SimpleFields.CustomButton(None, 'Game text speed')
        b_text_speed.setToolTip('overrides the games default text speed when displaying text, \n'
                                 'standing for characters per second. Useful given the game by default\n'
                                 ' has all text display instantly.')
        b_text_speed.clicked.connect(lambda: self.area_input.insert_text('{nw}'))
        h_lay_4.addWidget(b_text_speed)
        b_after_end = SimpleFields.CustomButton(None, 'Move after End')
        b_after_end.setToolTip('placed anywhere in the string causes the displayed text to automatically\n'
                               'move to the next screen once the final character has been displayed. \n'
                               'Given MGD by default has all text display instantly, this typically\n'
                               'won’t be too useful unless combined with the {cps}.')
        b_after_end.clicked.connect(lambda: self.area_input.insert_text('{}'))
        h_lay_4.addWidget(b_after_end)
        b_remove_after = SimpleFields.CustomButton(None, 'Remove After')
        b_remove_after.setToolTip('exists specifically for technical use with OnPlayerOrgasm,\n'
                                  'ensuring any text in a string after it is called is removed')
        b_remove_after.clicked.connect(lambda: self.area_input.insert_text('|c|'))
        h_lay_4.addWidget(b_remove_after)
        b_split_text = SimpleFields.CustomButton(None, 'Split Text')
        b_split_text.setToolTip('splits the string, causing everything after the |n|, to display on the next screen of'
                                ' text. Useful for long attack descriptions or player orgasm lines')
        b_split_text.clicked.connect(lambda: self.area_input.insert_text('|c|'))
        h_lay_4.addWidget(b_split_text)
        b_vSpace = SimpleFields.CustomButton(None, 'V Space')
        b_vSpace.setToolTip('insert vertical space.')
        b_vSpace.clicked.connect(lambda: self.area_input.insert_text('{vspace=}'))
        h_lay_4.addWidget(b_vSpace)
        b_hSpace = SimpleFields.CustomButton(None, 'V Space')
        b_hSpace.setToolTip('insert horizontal space.')
        b_hSpace.clicked.connect(lambda: self.area_input.insert_text('{space=}'))
        h_lay_4.addWidget(b_hSpace)
        v_lay_main.addLayout(h_lay_4)

        h_lay_5 = QtWidgets.QHBoxLayout()
        b_sex_adjective = SimpleFields.CustomButton(None, 'Sex Adjective')
        b_sex_adjective.setToolTip('gets an adjective from the below bank, Vaginal or Anal based depending on stance.\n'
                                   'Note the space after each word. The empty string means it can roll a blank.\n'
                                   'Sex: [“”, “wet “, “tight “, “wet “, “tight “, “receptive “, “warm “]\n'
                                   'Anal: [“”, “tight “, “tight “, “curved “, “rounded “, “receptive “]')
        b_sex_adjective.clicked.connect(lambda: self.area_input.insert_text('{SexAdjective}'))
        h_lay_5.addWidget(b_sex_adjective)
        b_sex_word = SimpleFields.CustomButton(None, 'Sex Word')
        b_sex_word.setToolTip('gets a sex word from the bank, Vaginal or Anal based depending on stance.\n'
                                                      ' It will pick a string randomly from an array, depending on either sex or anal stance\n'
                                                      'Sex: [“pussy”, “pussy”, “slit”, “honeypot”]\n'
                                                      'Anal: [“ass”, “ass”, “rear”, “behind”, “derriere”]')
        b_sex_word.clicked.connect(lambda: self.area_input.insert_text('{SexWords}'))
        h_lay_5.addWidget(b_sex_word)
        simple_mark_ups = {'(Underline)': {'style': '', 'beg': '{u}', 'end': '{/u}', 'tooltip': ''},
                           '(Italic)': {'style': '', 'beg': '{i}', 'end': '{/i}', 'tooltip': ''},
                           '(Bold)': {'style': 'QPushButton { font-weight: bold; }', 'beg': '{b}', 'end': '{/b}', 'tooltip':''},
                           '(Strike)': {'style': '', 'beg': '{s}', 'end': '{/s}', 'tooltip': ''},
                           '(Plain)': {'style': '', 'beg': '{plain}', 'end': '{/plain}', 'tooltip': ''},
                           '(Size)': {'style': '', 'beg': '{size=}', 'end': '{/size}', 'tooltip':'will make the following text size equal to the given integer value after = in the markup.\n'
                                                      'You can also make it relatively bigger or smaller compared to its previous state based\n'
                                                      ' on the given value through the use of either +int or -int.\n'
                                                      ' You can layer them inside one another, but note {/size} will not end all instances of {size=int}, only one instance at a time.'}}
        last_row_button = []
        for marks in simple_mark_ups:
            # b_simple_markup = SimpleFields.CustomButton(None, marks)
            b_simple_markup = QtWidgets.QPushButton(text=marks)
            if simple_mark_ups[marks]['tooltip']:
                b_simple_markup.setToolTip(simple_mark_ups[marks]['tooltip'])
            if simple_mark_ups[marks]['style']:
                b_simple_markup.setStyleSheet(simple_mark_ups[marks]['style'])
            # b_simple_markup.clicked.connect(lambda: self.area_input.mark_text(marks, simple_mark_ups[marks]['end']))
            # b_simple_markup.clicked.connect(lambda: self.area_input.mark_text(simple_mark_ups[marks]['beg'], simple_mark_ups[marks]['end']))
            h_lay_5.addWidget(b_simple_markup)
            last_row_button.append(b_simple_markup)
        custom_font = last_row_button[3].font()
        custom_font.setStrikeOut(True)
        last_row_button[3].setFont(custom_font)
        custom_font = last_row_button[1].font()
        custom_font.setItalic(True)
        last_row_button[1].setFont(custom_font)
        custom_font = last_row_button[0].font()
        custom_font.setUnderline(True)
        last_row_button[0].setFont(custom_font)

        last_row_button[0].clicked.connect(lambda: self.area_input.mark_text(simple_mark_ups['U']['beg'], simple_mark_ups['U']['end']))
        last_row_button[1].clicked.connect(lambda: self.area_input.mark_text(simple_mark_ups['I']['beg'], simple_mark_ups['I']['end']))
        last_row_button[2].clicked.connect(lambda: self.area_input.mark_text(simple_mark_ups['B']['beg'], simple_mark_ups['B']['end']))
        last_row_button[3].clicked.connect(lambda: self.area_input.mark_text(simple_mark_ups['S']['beg'], simple_mark_ups['S']['end']))
        last_row_button[4].clicked.connect(lambda: self.area_input.mark_text(simple_mark_ups['P']['beg'], simple_mark_ups['P']['end']))
        last_row_button[5].clicked.connect(lambda: self.area_input.mark_text(simple_mark_ups['Size']['beg'], simple_mark_ups['Size']['end']))


        v_lay_main.addLayout(h_lay_5)

        self.mark_up_buttons_background_player.setLayout(v_lay_main)
        return

    def put_text(self, val):
        self.area_input.insert_text(val)

    def show_color_picker(self, field_to_colour):
        # Create a color dialog
        color_dialog = QtWidgets.QColorDialog(self)

        # Get the selected color from the dialog
        color = color_dialog.getColor()

        if color.isValid():
            # Update the button's background color
            field_to_colour.setStyleSheet("background-color: " + color.name() + ";")
    def colour_text(self, field_with_colour):
        return
    #     TODO
    def player_name(self, value):
        if value != 'Player Name':
            if value == 'normal':
                self.area_input.insert_text('{ThePlayerName}')
            if value == 'shout':
                self.area_input.insert_text('{THEPLAYERNAME}')
            if value == 'initials':
                self.area_input.insert_text('{TPN}')
        self.l_player_name.setCurrentIndex(0)
        self.area_input.setFocus()
    def damage_target(self, value):
        if value != 'Damage Target':
            if value == 'player':
                self.area_input.insert_text('{DamageToPlayer}')
            if value == 'enemy':
                self.area_input.insert_text('{DamageToEnemy}')
            if value == 'final':
                self.area_input.insert_text('{FinalDamage}')
        self.l_damage_target.setCurrentIndex(0)
        self.area_input.setFocus()
    def mark(self, field):
        if field.currentIndex() > 0:
            self.area_input.insert_text('{'+field.itemText(0)+field.get_val()+'}')
            field.setCurrentIndex(0)
    # def on_checkbox_toggled(self, checkbox, checked):
    #     if checked:
    #         for button in self.button_group.buttons():
    #             # TODO change back to black, this is not working
    #             button.setStyleSheet("QCheckBox { color: blue }")
    #             if button != checkbox:
    #                 button.setChecked(False)
    #         if checkbox.text() == 'EVENT':
    #             self.functions.target_type = [1, self.display_data]
    #         else:
    #             self.functions.target_type = [0, self.area_input]

    def display_scene_list(self):
        if self.scene_list.isVisible():
            self.scene_list.hide()
        else:
            self.scene_list.show()
        return

    def change_size(self, param):
        self.adjustSize()
        # value = int(self.text_test.get_val())
        # if param == 1:
        #     self.area_input.setMaximumWidth(value)
        # else:
        #     self.area_input.setMaximumHeight(value)
        # self.area_input.set_val('width - ' + str(self.area_input.size().width()) + ', heigh - ' + str(self.area_input.size().height()))
    # def retranslateUi(self, dialog):
    #     _translate = QtCore.QCoreApplication.translate
    #     dialog.setWindowTitle(_translate("Dialog", "Event Text"))
    def update_row(self):
        selected_item = self.display_data.selected_element()
        if selected_item.whatsThis() != 'function':
        # if selected_item.parent() is None or (selected_item.parent() and isinstance(selected_item.text(), int)):
            self.area_input.clear_val()
            self.area_input.set_val(selected_item.text())
            self.area_input.flag_update = True
    def save_data(self):

        return
    def switch_to_data(self):
        if self.flag_data:
            """if true, hide data and display scenes"""
            self.flag_data = False
            self.display_data.show()
            self.scene_data_widget_background.hide()
            if self.flag_main_data:
                self.functions.treeview_main_game_items.hide()
        else:
            """if false, show data and hide scenes"""
            self.flag_data = True
            self.display_data.hide()
            self.scene_data_widget_background.show()
            if self.flag_main_data:
                self.functions.treeview_main_game_items.show()

    def load_scene_to_display(self):
        """user double cliked on scene in scene lookup. if its parent, clear display, if not, load scene"""
        self.display_data.clear_tree()
        item_data = self.scene_list.selected_element()
        scene_data = []
        if item_data.parent():
            for scene_type in self.current_scenes:
                for scene in self.current_scenes[scene_type]:
                    if scene == item_data.text():
                        scene_data = self.current_scenes[scene_type][scene]['theScene']
                        break
                if scene_data:
                    break
        else:
            self.display_scene_list()
            return
        """now go over scene data, compare each row with functions. """
        self.display_data.add_data(scene_data)
        # for scene_row in scene_data:
        #     temp = scene_row.split(' ')
        #     if temp[0] in self.functions_list:
        #         # TODO finish this
        #         print('found functions')
        #         print(scene_row)
    def test(self):
        temp = self.area_input.textCursor()
        print(temp.selectionStart())
        print(temp.selectionEnd())
        print(temp.selectedText())