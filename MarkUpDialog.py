# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'VisualOptions.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
import SimpleFields
import GlobalVariables
from Function_class import Function_Gui
from otherFunctions import wrap, show_message


class area_mark_up(SimpleFields.AreaEntry):
    def __init__(self):
        super().__init__(edit=False)
        """if opening from event, it should add text to display field. but if opening from simple text field
        it should probably not do anything"""
        self.return_target = None
        """if doubleclicked on treeview, then update current text"""
        self.flag_update = False

    def keyPressEvent(self, event: QtGui.QKeyEvent):
        if self.return_target:
            if event.key() == QtCore.Qt.Key_Return:
                self.add_verse()
                return
            elif event.key() == QtCore.Qt.Key_Escape:
                self.clear_val()
                self.flag_update = False
        super().keyPressEvent(event)

    def add_verse(self):
        text = wrap(self.get_val(), length=50)
        if text:
            if self.flag_update:
                self.return_target.update_leaf(text)
                self.flag_update = False
            elif self.return_target.selected_element():
                """if already selected something, then insert above it"""
                self.return_target.insert_row([text])
            else:
                self.return_target.add_data(data=text)
            self.clear_val()

    def insert_text(self, text):
        """insert value where cursor is."""
        self.insertPlainText(text)
        self.setFocus()

    def mark_text(self, beg, end):
        cursor = self.textCursor()
        if cursor.selectedText():
            new_text = beg + cursor.selectedText() + end
            self.insertPlainText(new_text)
            self.setFocus()


class MarkUp_Window(QtWidgets.QWidget):
    def __init__(self, target_field=None, scenes_flag=None, data_for_functions=None, current_scene_list=None,
                 scene_data=None, quick_load_scene=None):
        super().__init__()
        """target field - either treeview for scenes or text field for some fields that allow markups
        scenes_flag - if textfied is target, no need to display treeview for scenes
        data for functions - ...hmm..probably it should pass info whenever it should display all function or only txt"""
        self.setWindowTitle('Events')
        # Dialog.resize(310, 299)
        # self.widget.setGeometry(QtCore.QRect(0, 10, 301, 281))
        self.setObjectName("FunctionWin")
        self.resize(900, 500)

        self.v_main_layout = QtWidgets.QVBoxLayout(self)
        self.v_main_layout.setContentsMargins(0, 0, 0, 0)
        self.v_main_layout.setObjectName("mainLayout")
        self.setLayout(self.v_main_layout)

        v_layout_buttons = QtWidgets.QHBoxLayout()
        v_layout_buttons.setObjectName("button_layout")
        self.mark_up_buttons_background_player = QtWidgets.QWidget()
        self.mark_up_buttons_background_text = QtWidgets.QWidget()
        """all the buttons for markups here"""
        self.prepare_markup_buttons()
        """below are placeholder to test sizes"""
        # placeholder_buttons = SimpleFields.CustomButton(self, 'placeholder width')
        # # placeholder_buttons.clicked.connect(lambda: self.change_size(1))
        # placeholder_buttons.clicked.connect(self.test)
        # placeholder_buttons2 = SimpleFields.CustomButton(self, 'placeholder2 heigh')
        # placeholder_buttons2.clicked.connect(lambda: self.change_size(2))
        # h_layout_buttons.addWidget(placeholder_buttons)
        # h_layout_buttons.addWidget(placeholder_buttons2)
        # self.v_main_layout.addLayout(v_layout_buttons)
        self.v_main_layout.addWidget(self.mark_up_buttons_background_player)
        self.v_main_layout.addWidget(self.mark_up_buttons_background_text)
        """Area text for input and later treeview for display,
        treeview for functions and functions creation on right"""
        """first, vertical, contains area text and treeview"""
        self.area_input = area_mark_up()
        self.area_input.setMaximumSize(800, 100)
        self.area_input.set_up_widget(self.v_main_layout)
        """now, display data on the left and on the right functions gui"""
        """on the left is treeview for data from input, hidden scene list and hidden scene data.
        on the right area with explanation, treeview with functions and 2 buttons"""
        h_layout_display_f_gui = QtWidgets.QHBoxLayout()
        v_layout_left_side = QtWidgets.QVBoxLayout()
        """target field is field from which user entered. 
        this markup window should work for scene and some normal text fields"""
        self.target_field = target_field
        if current_scene_list:
            self.current_scenes = current_scene_list
            self.functions_list = list(GlobalVariables.Glob_Var.functions_data.keys())
        else:
            self.current_scenes = None
        if scenes_flag:
            """first horizontal to put buttons at the top"""
            h_lay_scene_buttons = QtWidgets.QHBoxLayout()
            self.button_display_scenes = SimpleFields.CustomButton(None, 'Scenes')
            self.button_display_scenes.setMaximumWidth(100)
            self.button_display_scenes.clicked.connect(self.display_scene_list)
            h_lay_scene_buttons.addWidget(self.button_display_scenes)
            self.button_display_scenes_data = SimpleFields.CustomButton(None, 'Data')
            self.button_display_scenes_data.setMaximumWidth(100)
            self.button_display_scenes_data.clicked.connect(self.switch_to_data)
            self.flag_data = False
            h_lay_scene_buttons.addWidget(self.button_display_scenes_data)
            self.button_load_function = SimpleFields.CustomButton(None, '>>')
            self.button_load_function.setMaximumWidth(100)
            self.button_load_function.clicked.connect(self.load_function)
            h_lay_scene_buttons.addWidget(self.button_load_function)
            """now add horizontal, to put scene list and scene text next to each other.
            Also, so I dont have to resize them each time, put it on a background widget"""
            h_layout_display = QtWidgets.QHBoxLayout()
            self.display_scene_widget_background = QtWidgets.QWidget()
            # self.display_scene_widget_background.setMaximumWidth(400)
            # self.display_scene_widget_background.setFixedWidth(400)
            # sp = self.display_scene_widget_background.sizePolicy()
            # sp.setHorizontalPolicy(QtWidgets.QSizePolicy.Expanding)
            # self.display_scene_widget_background.setSizePolicy(sp)
            temp_lay = QtWidgets.QHBoxLayout()
            self.display_scene_widget_background.setLayout(temp_lay)
            h_layout_display.addWidget(self.display_scene_widget_background)
            # v_layout_display.addLayout(h_layout_display)
            self.scene_list = SimpleFields.ElementsList(self, search_field=True)
            """since this scene list is basicly same as in function field in main view, instead to duplicatind
            data and after done making a copy, I passed tree models and assigned them here.
            This way any changes should be reflected in both treeviews.
            added if for testing"""
            if target_field:
                self.scene_list.tree_model = self.target_field.tree_model
                self.scene_list.sorting = self.target_field.sorting
                self.scene_list.setModel(self.scene_list.sorting)
            else:
                temp = {}
                if self.current_scenes:
                    for event_type in self.current_scenes:
                        templist = []
                        for scene_name in self.current_scenes[event_type]:
                            templist.append(scene_name)
                        temp[event_type] = templist
                    self.scene_list.add_data(temp)
            self.scene_list.set_up_widget(temp_lay)
            self.scene_list.hide()
            self.scene_list.doubleClicked.connect(self.load_scene_to_display)
            """hidden setup of basic scene data"""
            v_layout_display_scene_data = QtWidgets.QVBoxLayout()
            self.scene_data_widget_background = QtWidgets.QWidget()
            self.scene_data_widget_background.setLayout(v_layout_display_scene_data)
            h_layout_display.addWidget(self.scene_data_widget_background)
            """first, clean it to make it easier"""
            self.data_fields = []
            self.data_fields = {}
            self.flag_main_data = False
            """creating fields for scene data moved later, after function gui is created. to save space
            for monster, some fields are connected to fields created in functions gui"""
            # if scene_data:
            #     for data_field in scene_data:
            #         for field in scene_data[data_field]:
            #             if field != 'theScene':
            #                 """the scene is created separately in main view, other fields are in hidden view"""
            #                 self.data_fields[field] = scene_data[data_field][field]
            #     for fieldname in self.data_fields:
            #         """now, same as in custome fields, create appropiate fields"""
            #         if self.data_fields[fieldname]["type"] == "text":
            #             tempfield = SimpleFields.SimpleEntry(master_widget=self.scene_data_widget_background, field_name=fieldname,
            #                                                  field_data=self.data_fields[fieldname],
            #                                                  main_data_treeview=temp_mainfield_data, label_pos='V')
            #         elif self.data_fields[fieldname]["type"] == "int":
            #             tempfield = SimpleFields.NumericEntry(master=self.scene_data_widget_background, wid=4, field_name=fieldname,
            #                                                   field_data=self.data_fields[fieldname])
            #         elif self.data_fields[fieldname]["type"] == "singlelist":
            #             field_optionbox = SimpleFields.SingleList(self.scene_data_widget_background, fieldname, self.data_fields[fieldname])
            #             # field_optionbox.configure(takefocus=1)
            #             tempfield = field_optionbox
            #         elif self.data_fields[fieldname]["type"] == "filePath":
            #             tempfield = SimpleFields.FileField(self.scene_data_widget_background, fieldname, field_data=self.data_fields[fieldname])
            #         elif self.data_fields[fieldname]["type"] == 'area':
            #             tempfield = SimpleFields.AreaEntry(self.scene_data_widget_background, fieldname)
            #         elif self.data_fields[fieldname]["type"] == 'multilist':
            #             tempfield = SimpleFields.MultiListDisplay(self.scene_data_widget_background, fieldname, self.data_fields[fieldname],
            #                                                       main_data_treeview=temp_mainfield_data)
            #             self.flag_main_data = True
            #         self.data_fields[fieldname] = tempfield
            #         tempfield.set_up_widget(v_layout_display_scene_data)
            #         # v_layout_display_scene_data.addWidget(tempfield)
            self.scene_data_widget_background.hide()
            # h_layout_display.addWidget(self.scene_data_widget_background)
            """here is display data. is where iines and functions for scene are displayed and can be modified"""
            self.display_data = SimpleFields.ElementsList(self, "Event text")
            # self.display_data.setMaximumSize(600, 350)
            self.display_data.parent_tag = 'function'
            self.display_data.setMinimumWidth(100)
            self.display_data.setMinimumWidth(300)
            self.display_data.set_up_widget(h_layout_display)
            self.display_data.doubleClicked.connect(self.update_row)
            # self.data_fields['theScene'] = self.display_data
            # h_layout_display_f_gui.addLayout(H_layout_display)
            v_layout_left_side.addLayout(h_lay_scene_buttons)
            v_layout_left_side.addLayout(h_layout_display)
        else:
            self.scene_list = None
            self.display_data = None
            self.scene_button = None

        v_layout_right_side = QtWidgets.QVBoxLayout()
        h_layout_display_f_gui.addLayout(v_layout_left_side)
        h_layout_display_f_gui.addLayout(v_layout_right_side)
        """layout for functions field creations, already added"""
        self.v_layout_function_fields = QtWidgets.QVBoxLayout()
        self.v_layout_function_fields.setObjectName('function_fields_layout')
        h_layout_display_f_gui.addLayout(self.v_layout_function_fields)
        h_layout_display_f_gui.addStretch(1)
        """functions gui"""
        if scenes_flag:
            config_list = [1, self.area_input, self.display_data]
        else:
            config_list = [0, self.area_input, None]
        self.functions = Function_Gui(None, None, self, fields_lay=self.v_layout_function_fields,
                                      adding_config=config_list, scene_list=current_scene_list)
        self.functions.set_up_widget(v_layout_right_side)
        """now create fields for scene data, so it has access to functions gui main data tree
        moved from above"""
        if scene_data:
            for data_field in scene_data:
                for field in scene_data[data_field]:
                    if field != 'theScene':
                        """the scene is created separately in main view, other fields are in hidden view"""
                        self.data_fields[field] = scene_data[data_field][field]
            for fieldname in self.data_fields:
                """now, same as in custome fields, create appropiate fields"""
                if self.data_fields[fieldname]["type"] == "text":
                    tempfield = SimpleFields.SimpleEntry(master_widget=self.scene_data_widget_background,
                                                         field_name=fieldname,
                                                         field_data=self.data_fields[fieldname],
                                                         main_data_treeview=self.functions.treeview_main_game_items, label_pos='V')
                    tempfield.label_custom.change_position('C')
                elif self.data_fields[fieldname]["type"] == "int":
                    tempfield = SimpleFields.NumericEntry(master=self.scene_data_widget_background, wid=4,
                                                          field_name=fieldname,
                                                          field_data=self.data_fields[fieldname])
                elif self.data_fields[fieldname]["type"] == "singlelist":
                    field_optionbox = SimpleFields.SingleList(self.scene_data_widget_background, fieldname,
                                                              self.data_fields[fieldname])
                    tempfield = field_optionbox
                elif self.data_fields[fieldname]["type"] == "filePath":
                    tempfield = SimpleFields.FileField(self.scene_data_widget_background, fieldname,
                                                       field_data=self.data_fields[fieldname])
                elif self.data_fields[fieldname]["type"] == 'area':
                    tempfield = SimpleFields.AreaEntry(self.scene_data_widget_background, fieldname)
                elif self.data_fields[fieldname]["type"] == 'multilist':
                    tempfield = SimpleFields.MultiListDisplay(self.scene_data_widget_background, fieldname,
                                                              self.data_fields[fieldname],
                                                              main_data_treeview=self.functions.treeview_main_game_items)
                    self.flag_main_data = True
                self.data_fields[fieldname] = tempfield
                tempfield.set_up_widget(v_layout_display_scene_data)
                # v_layout_display_scene_data.addWidget(tempfield)
            v_layout_display_scene_data.addStretch(1)
            self.data_fields['theScene'] = self.display_data
        """here ends cut in of fields creation"""

        self.v_layout_function_fields.addStretch(1)
        self.v_main_layout.addLayout(h_layout_display_f_gui)
        h_final_buttons_layout = QtWidgets.QHBoxLayout()
        but_save = SimpleFields.CustomButton(None, 'SAVE')
        but_save.setMaximumWidth(100)
        but_save.clicked.connect(self.save_data)
        h_final_buttons_layout.addWidget(but_save)
        but_cancel = SimpleFields.CustomButton(None, 'CANCEL/NEW')
        but_cancel.setMaximumWidth(100)
        but_cancel.clicked.connect(self.cancel_scene)
        h_final_buttons_layout.addWidget(but_cancel, alignment=QtCore.Qt.AlignLeft)
        but_done = SimpleFields.CustomButton(None, '!!DONE!!')
        but_done.setMaximumWidth(100)
        but_done.clicked.connect(self.done)
        h_final_buttons_layout.addWidget(but_done, alignment=QtCore.Qt.AlignLeft)
        h_final_buttons_layout.addStretch(1)
        self.v_main_layout.addLayout(h_final_buttons_layout)
        #
        # v_layout_function_fields = QtWidgets.QVBoxLayout()
        # # self.functions = Function_Gui(self.flag_function_target_type, None, fields_lay=v_layout_function_fields)
        # # self.functions.set_up_widget(v_layout_function_window)
        #
        # h_lay_functions_main.addLayout(v_layout_function_window)
        # h_lay_functions_main.addLayout(v_layout_function_fields)

        # self.buttonBox = QtWidgets.QDialogButtonBox(self)
        # self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
        # self.buttonBox.setStandardButtons(QtWidgets.QDialogButtonBox.Cancel | QtWidgets.QDialogButtonBox.Ok)
        # self.buttonBox.setObjectName("buttonBox")
        # self.v_main_layout.addWidget(self.buttonBox)
        #
        # self.retranslateUi(Dialog)
        # self.buttonBox.accepted.connect(Dialog.accept)
        # self.buttonBox.rejected.connect(Dialog.reject)
        # QtCore.QMetaObject.connectSlotsByName(Dialog)
        if scenes_flag:
            self.area_input.return_target = self.display_data
            if quick_load_scene:
                self.load_scene_to_display(quick_load_scene)
                # print(quick_load_scene.data())
                self.scene_list.select_element(quick_load_scene)

    def done(self):
        if self.display_data:
            check_if_data_remains = self.display_data.get_data()
            if check_if_data_remains:
                qm = QtWidgets.QMessageBox()
                answer = qm.question(None, 'Not done', "Are you sure you are done with scenes?", qm.Yes | qm.No)
                if answer == qm.No:
                    return
        self.close()

    def load_function(self):
        selected_item = self.display_data.selected_element()
        if selected_item:
            if selected_item.parent():
                parent = selected_item.parent()
            elif selected_item.child(0, 0):
                parent = selected_item
            else:
                return
            data = []
            """for some reason it works. probably its like that for folders"""
            self.display_data.get_data(parent_index=parent, root_list=data)
            data = data[0]
            f_data = list(data.keys())
            f_data += data[f_data[0]]
            """now fdata is dictionary with key as function title and list of function values"""
            self.functions.display_explanation(function_title=f_data[0])
            self.functions.prepare_function_fields(f_data)

    def prepare_markup_buttons(self):
        v_lay_main = QtWidgets.QVBoxLayout()
        label_chara = SimpleFields.CustomLabel(None, 'CHARACTER')
        label_chara.change_position('C')
        v_lay_main.addWidget(label_chara)
        h_lay_first = QtWidgets.QHBoxLayout()
        self.l_player_name = SimpleFields.SingleList(label_text='testerror', edit=False, field_data={'choices':['Player Name', 'normal', 'shout', 'initials']})
        # self.l_player_name.reload_options(['Player Name', 'normal', 'shout', 'initials'])
        self.l_player_name.currentTextChanged.connect(self.player_name)
        h_lay_first.addWidget(self.l_player_name)

        b_player_money = SimpleFields.CustomButton(None, 'Player Money')
        b_player_money.clicked.connect(lambda: self.area_input.insert_text('{PlayerMoney}'))
        h_lay_first.addWidget(b_player_money)
        b_player_progress = SimpleFields.CustomButton(None, 'Player Progress')
        b_player_progress.clicked.connect(lambda: self.area_input.insert_text('{ProgressDisplay}'))
        h_lay_first.addWidget(b_player_progress)
        b_player_level = SimpleFields.CustomButton(None, 'Player Level')
        b_player_level.clicked.connect(lambda: self.area_input.insert_text('{PlayerLevel}'))
        h_lay_first.addWidget(b_player_level)
        h_lay_first.addStretch(1)
        b_player_choice = SimpleFields.CustomButton(None, 'Player Choice')
        b_player_choice.clicked.connect(lambda: self.area_input.insert_text('{DisplayPlayerChoice}'))
        h_lay_first.addWidget(b_player_choice, alignment=QtCore.Qt.AlignRight)
        b_player_orgasm = SimpleFields.CustomButton(None, 'Player Orgasm')
        b_player_orgasm.setToolTip('displays the orgasm line for the player or monster respectively.\n'
                                   ' To be used with OnPlayerOrgasm and OnOrgasm lineTriggers utilizing events respectively. \n'
                                   'If using it in a loop, use the EmptySpiritCounter function after the line \n'
                                   'to empty out how much spirit is counted')
        b_player_orgasm.clicked.connect(lambda: self.area_input.insert_text('{PlayerOrgasmLine}'))
        h_lay_first.addWidget(b_player_orgasm, alignment=QtCore.Qt.AlignRight)
        v_lay_main.addLayout(h_lay_first)

        h_lay_second = QtWidgets.QHBoxLayout()
        self.l_damage_target = SimpleFields.SingleList(edit=False)
        self.l_damage_target.reload_options(['Damage Target', 'player', 'enemy', 'final'])
        self.l_damage_target.currentTextChanged.connect(self.damage_target)
        h_lay_second.addWidget(self.l_damage_target)

        self.l_mark_1 = SimpleFields.SingleList(edit=False)
        self.l_mark_1.reload_options(['Attacker', 'YouOrMonsterName', 'HeOrShe', 'HisOrHer', 'HimOrHer'])
        self.l_mark_1.currentTextChanged.connect(lambda: self.mark(self.l_mark_1))
        h_lay_second.addWidget(self.l_mark_1)
        self.l_mark_2 = SimpleFields.SingleList(edit=False)
        # self.l_mark_2.reload_options(['ATarget', 'YouOrMonsterName', 'HeOrShe', 'HisOrHer', 'HimOrHer'])
        self.l_mark_2.set_val(['Target', 'YouOrMonsterName', 'HeOrShe', 'HisOrHer', 'HimOrHer'], sort=False)
        self.l_mark_2.currentTextChanged.connect(lambda: self.mark(self.l_mark_2))
        h_lay_second.addWidget(self.l_mark_2)
        h_lay_second.addStretch(1)
        b_m_choice = SimpleFields.CustomButton(None, 'Monster Choice')
        b_m_choice.clicked.connect(lambda: self.area_input.insert_text('{DisplayMonsterChoice}'))
        h_lay_second.addWidget(b_m_choice, alignment=QtCore.Qt.AlignRight)
        b_m_orgasm = SimpleFields.CustomButton(None, 'Monster Orgasm')
        b_m_orgasm.clicked.connect(lambda: self.area_input.insert_text('{MonsterOrgasmLine}'))
        h_lay_second.addWidget(b_m_orgasm, alignment=QtCore.Qt.AlignRight)
        v_lay_main.addLayout(h_lay_second)

        """second part"""

        label_text = SimpleFields.CustomLabel(None, 'TEXT')
        label_text.change_position('C')
        v_lay_main.addWidget(label_text)

        h_lay_3 = QtWidgets.QHBoxLayout()
        b_colour_text = SimpleFields.CustomButton(None, 'C TEXT')
        h_lay_3.addWidget(b_colour_text)
        b_colour_example1 = SimpleFields.CustomButton(None, 'EXAMPLE')
        b_colour_example1.setEnabled(False)
        h_lay_3.addWidget(b_colour_example1)
        b_colour_text.clicked.connect(lambda: self.show_color_picker(b_colour_example1))
        b_colour_example1.clicked.connect(lambda: self.colour_text(b_colour_example1))
        b_colour_outline = SimpleFields.CustomButton(None, 'C OUTLINE')
        h_lay_3.addWidget(b_colour_outline)
        b_colour_example2 = SimpleFields.CustomButton(None, 'EXAMPLE')
        b_colour_example2.setEnabled(False)
        h_lay_3.addWidget(b_colour_example2)
        b_colour_outline.clicked.connect(lambda: self.show_color_picker(b_colour_example2))
        b_colour_example2.clicked.connect(lambda: self.colour_text(b_colour_example2))

        b_delay_input = SimpleFields.CustomButton(None, 'Delay until input')
        b_delay_input.setToolTip('will delay the displayed text till user input is given to signal it to continue.\n'
                                 ' It can be given an integer value via {w=int} to make it wait the given\n'
                                 ' integer number in seconds, though it can continue early through user input\n'
                                 ' before the given time has elapsed.')
        b_delay_input.clicked.connect(lambda: self.area_input.insert_text('{w}'))
        h_lay_3.addWidget(b_delay_input)
        b_delay_nline = SimpleFields.CustomButton(None, 'Delay until new line')
        b_delay_nline.setToolTip('same as input but inserts line breaks for every time it is called')
        b_delay_nline.clicked.connect(lambda: self.area_input.insert_text('{p}'))
        h_lay_3.addWidget(b_delay_nline)
        b_get_over = SimpleFields.CustomButton(None, 'Get over here')
        b_get_over.setToolTip('placed anywhere in the string causes the displayed text to instantly move towards the markup declaration. \n'
                              'Given MGD by default has all text display instantly, this typically won’t be too useful unless combined with the {cps}')
        b_get_over.clicked.connect(lambda: self.area_input.insert_text('{nw}'))
        h_lay_3.addWidget(b_get_over)
        v_lay_main.addLayout(h_lay_3)

        h_lay_4 = QtWidgets.QHBoxLayout()
        b_text_speed = SimpleFields.CustomButton(None, 'Game text speed')
        b_text_speed.setToolTip('overrides the games default text speed when displaying text, \n'
                                 'standing for characters per second. Useful given the game by default\n'
                                 'has all text display instantly.')
        b_text_speed.clicked.connect(lambda: self.area_input.insert_text('{cps=int}'))
        h_lay_4.addWidget(b_text_speed)
        b_after_end = SimpleFields.CustomButton(None, 'Move after End')
        b_after_end.setToolTip('placed anywhere in the string causes the displayed text to automatically\n'
                               'move to the next screen once the final character has been displayed. \n'
                               'Given MGD by default has all text display instantly, this typically\n'
                               'won’t be too useful unless combined with the {cps}.')
        b_after_end.clicked.connect(lambda: self.area_input.insert_text('{fast}'))
        h_lay_4.addWidget(b_after_end)
        b_remove_after = SimpleFields.CustomButton(None, 'Remove After')
        b_remove_after.setToolTip('exists specifically for technical use with OnPlayerOrgasm,\n'
                                  'ensuring any text in a string after it is called is removed')
        b_remove_after.clicked.connect(lambda: self.area_input.insert_text('|c|'))
        h_lay_4.addWidget(b_remove_after)
        b_split_text = SimpleFields.CustomButton(None, 'Split Text')
        b_split_text.setToolTip('splits the string, causing everything after the |n|, to display on the next screen of'
                                ' text. Useful for long attack descriptions or player orgasm lines')
        b_split_text.clicked.connect(lambda: self.area_input.insert_text('|n|'))
        h_lay_4.addWidget(b_split_text)
        b_vSpace = SimpleFields.CustomButton(None, 'V Space')
        b_vSpace.setToolTip('insert vertical space.')
        b_vSpace.clicked.connect(lambda: self.area_input.insert_text('{vspace=}'))
        h_lay_4.addWidget(b_vSpace)
        b_hSpace = SimpleFields.CustomButton(None, 'Space')
        b_hSpace.setToolTip('insert horizontal space.')
        b_hSpace.clicked.connect(lambda: self.area_input.insert_text('{space=}'))
        h_lay_4.addWidget(b_hSpace)
        v_lay_main.addLayout(h_lay_4)

        h_lay_5 = QtWidgets.QHBoxLayout()
        b_sex_adjective = SimpleFields.CustomButton(None, 'Sex Adjective')
        b_sex_adjective.setToolTip('gets an adjective from the below bank, Vaginal or Anal based depending on stance.\n'
                                   'Note the space after each word. The empty string means it can roll a blank.\n'
                                   'Sex: [“”, “wet “, “tight “, “wet “, “tight “, “receptive “, “warm “]\n'
                                   'Anal: [“”, “tight “, “tight “, “curved “, “rounded “, “receptive “]')
        b_sex_adjective.clicked.connect(lambda: self.area_input.insert_text('{SexAdjective}'))
        h_lay_5.addWidget(b_sex_adjective)
        b_sex_word = SimpleFields.CustomButton(None, 'Sex Word')
        b_sex_word.setToolTip('gets a sex word from the bank, Vaginal or Anal based depending on stance.\n'
                                                      ' It will pick a string randomly from an array, depending on either sex or anal stance\n'
                                                      'Sex: [“pussy”, “pussy”, “slit”, “honeypot”]\n'
                                                      'Anal: [“ass”, “ass”, “rear”, “behind”, “derriere”]')
        b_sex_word.clicked.connect(lambda: self.area_input.insert_text('{SexWords}'))
        h_lay_5.addWidget(b_sex_word)
        simple_mark_ups = {'(U)': {'style': '', 'beg': '{u}', 'end': '{/u}', 'tooltip': ''},
                           '(I)': {'style': '', 'beg': '{i}', 'end': '{/i}', 'tooltip': ''},
                           '(B)': {'style': 'QPushButton { font-weight: bold; }', 'beg': '{b}', 'end': '{/b}', 'tooltip':''},
                           '(S)': {'style': '', 'beg': '{s}', 'end': '{/s}', 'tooltip': ''},
                           '(Plain)': {'style': '', 'beg': '{plain}', 'end': '{/plain}', 'tooltip': ''},
                           '(Size)': {'style': '', 'beg': '{size=}', 'end': '{/size}', 'tooltip':'will make the following text size equal to the given integer value after = in the markup.\n'
                                                      'You can also make it relatively bigger or smaller compared to its previous state based\n'
                                                      ' on the given value through the use of either +int or -int.\n'
                                                      ' You can layer them inside one another, but note {/size} will not end all instances of {size=int}, only one instance at a time.'}}
        last_row_button = []
        for marks in simple_mark_ups:
            b_simple_markup = QtWidgets.QPushButton(text=marks)
            if simple_mark_ups[marks]['tooltip']:
                b_simple_markup.setToolTip(simple_mark_ups[marks]['tooltip'])
            if simple_mark_ups[marks]['style']:
                b_simple_markup.setStyleSheet(simple_mark_ups[marks]['style'])
            # b_simple_markup.clicked.connect(lambda: self.area_input.mark_text(marks, simple_mark_ups[marks]['end']))
            # b_simple_markup.clicked.connect(lambda: self.area_input.mark_text(simple_mark_ups[marks]['beg'], simple_mark_ups[marks]['end']))
            h_lay_5.addWidget(b_simple_markup)
            last_row_button.append(b_simple_markup)
        custom_font = last_row_button[3].font()
        custom_font.setStrikeOut(True)
        last_row_button[3].setFont(custom_font)
        custom_font = last_row_button[1].font()
        custom_font.setItalic(True)
        last_row_button[1].setFont(custom_font)
        custom_font = last_row_button[0].font()
        custom_font.setUnderline(True)
        last_row_button[0].setFont(custom_font)

        last_row_button[0].clicked.connect(lambda: self.area_input.mark_text(simple_mark_ups['(U)']['beg'], simple_mark_ups['(U)']['end']))
        last_row_button[1].clicked.connect(lambda: self.area_input.mark_text(simple_mark_ups['(I)']['beg'], simple_mark_ups['(I)']['end']))
        last_row_button[2].clicked.connect(lambda: self.area_input.mark_text(simple_mark_ups['(B)']['beg'], simple_mark_ups['(B)']['end']))
        last_row_button[3].clicked.connect(lambda: self.area_input.mark_text(simple_mark_ups['(S)']['beg'], simple_mark_ups['(S)']['end']))
        last_row_button[4].clicked.connect(lambda: self.area_input.mark_text(simple_mark_ups['(Plain)']['beg'], simple_mark_ups['(Plain)']['end']))
        last_row_button[5].clicked.connect(lambda: self.area_input.mark_text(simple_mark_ups['(Size)']['beg'], simple_mark_ups['(Size)']['end']))

        v_lay_main.addLayout(h_lay_5)
        self.mark_up_buttons_background_player.setLayout(v_lay_main)
        return

    # def put_text(self, val):
    #     self.area_input.insert_text(val)
    #     self.area_input.setFocus()

    def show_color_picker(self, field_to_colour):
        field_to_colour.setEnabled(True)
        # Create a color dialog
        color_dialog = QtWidgets.QColorDialog(self)
        # Get the selected color from the dialog
        color = color_dialog.getColor()
        if color.isValid():
            # Update the button's background color
            field_to_colour.setStyleSheet("background-color: " + color.name() + ";")
            field_to_colour.colour = color.name()

    def cancel_scene(self):
        self.area_input.clear_val()
        for field in self.data_fields:
            self.data_fields[field].clear_val()

    def colour_text(self, field_with_colour):
        colour_to_set = field_with_colour.colour
        self.area_input.mark_text('{SetTextColor}' + colour_to_set + '{Done}', '{ColorEnd}')

    def player_name(self, value):
        if value != 'Player Name':
            if value == 'normal':
                self.area_input.insert_text('{ThePlayerName}')
            if value == 'shout':
                self.area_input.insert_text('{THEPLAYERNAME}')
            if value == 'initials':
                self.area_input.insert_text('{TPN}')
        self.l_player_name.setCurrentIndex(0)
        self.area_input.setFocus()

    def damage_target(self, value):
        if value != 'Damage Target':
            if value == 'player':
                self.area_input.insert_text('{DamageToPlayer}')
            if value == 'enemy':
                self.area_input.insert_text('{DamageToEnemy}')
            if value == 'final':
                self.area_input.insert_text('{FinalDamage}')
        self.l_damage_target.setCurrentIndex(0)
        self.area_input.setFocus()

    def mark(self, field):
        """these are for dropdowns, like player target"""
        if field.currentIndex() > 0:
            self.area_input.insert_text('{'+field.itemText(0)+field.get_val()+'}')
            field.setCurrentIndex(0)

    def display_scene_list(self):
        if self.scene_list.isVisible():
            self.scene_list.hide()
        else:
            self.scene_list.show()

    def change_size(self, param):
        self.adjustSize()
        # value = int(self.text_test.get_val())
        # if param == 1:
        #     self.area_input.setMaximumWidth(value)
        # else:
        #     self.area_input.setMaximumHeight(value)
        # self.area_input.set_val('width - ' + str(self.area_input.size().width()) + ', heigh - ' + str(self.area_input.size().height()))
    # def retranslateUi(self, dialog):
    #     _translate = QtCore.QCoreApplication.translate
    #     dialog.setWindowTitle(_translate("Dialog", "Event Text"))

    def update_row(self):
        selected_item = self.display_data.selected_element()
        self.area_input.clear_val()
        self.area_input.set_val(selected_item.text())
        self.area_input.flag_update = True

    def save_data(self):
        if self.scene_list:
            """first, check if scene name is defined"""
            scene_title = self.data_fields['NameOfScene'].get_val()
            if not scene_title:
                show_message('Missing scene title', 'Please provide scene title', 'MissMandatory')
                return
            current_selection = self.scene_list.selected_element()
            if not current_selection:
                """if nothing selected. events scenes are 'EventText' while for monsters its 'loss or vistory scene'"""
                show_message('Missing scene type', 'Please select scene type from scene list(top item)', 'MisMandatory')
                return
            scene_data = {}
            """go over display data manually, whatever is nested need to be put top level.
            In the end, scene is a list of values"""
            scene_text = self.display_data.get_data()
            final_text = []
            for text in scene_text:
                if isinstance(text, dict):
                    for i in text:
                        final_text.append(i)
                        for ii in text[i]:
                            final_text.append(ii)
                else:
                    final_text.append(text)
            for fields in self.data_fields:
                # in case of theScene, getdata gathers it into dictionary, but should be a simple list - "finalText"
                if fields == 'theScene':
                    scene_data[fields] = final_text
                else:
                    scene_data[fields] = self.data_fields[fields].get_val()
            """now, put it in correct plane in scene container. in case of girls scenes, it might be win or lose
            so check what is selected and take its parent"""
            """now, how to save scene in scenelist"""
            insert_row = -1
            if current_selection.parent():
                """selected scene, not scene type, add above"""
                temp = current_selection.parent()
                scene_type = temp.text()
                insert_row = current_selection.row()
            else:
                """if no parent, selected scene type, add to it"""
                scene_type = current_selection.text()
            if scene_title not in list(self.current_scenes[scene_type].keys()):
                """if title already exists, then user is updating, no need to change, otherwise, insert or add new scene"""
                if insert_row > -1:
                    """user selected scene, insert new scene above selection"""
                    self.scene_list.insert_row([scene_title])
                else:
                    """user selected parent"""
                    self.scene_list.add_data([scene_title], current_selection)
            self.current_scenes[scene_type][scene_title] = scene_data
            # self.display_data.clear_tree()
            for field in self.data_fields:
                self.data_fields[field].clear_val()
        else:
            self.target_field.set_val(self.area_input.get_val())
            self.close()
    def switch_to_data(self):
        """scene data is additiona scene attributes. display data is scene context"""
        if self.flag_data:
            """if true, hide data and display scenes"""
            self.flag_data = False
            self.display_data.show()
            self.scene_data_widget_background.hide()
            if self.flag_main_data:
                self.functions.treeview_main_game_items.hide()
        else:
            """if false, show data and hide scenes"""
            self.flag_data = True
            self.display_data.hide()
            self.scene_data_widget_background.show()
            if self.flag_main_data:
                self.functions.treeview_main_game_items.show()

    def load_scene_to_display(self, clicked_index=None):
        """user double clicked on scene in scene lookup. if its parent, clear display, if not, load scene"""
        """clear display"""
        self.display_data.clear_tree()
        # item_data = self.scene_list.selected_element()
        item_data = self.scene_list.transform_index_to_item(clicked_index)
        if item_data.parent():
            """if it has parent, user clicked on specific scene. otherwise, there is nothing to load"""
            selected_scene_to_load = item_data.text()
            for scene_type in self.current_scenes:
                """scene type - eventScene, lossScene, VictoryScene"""
                if selected_scene_to_load in list(self.current_scenes[scene_type].keys()):
                    """In theory, I should be able to get scene type for item_data.parent() But this works too"""
                    scene_data = self.current_scenes[scene_type][item_data.text()]
                    for data in scene_data:
                        if data == 'theScene':
                            """now here it should go over all the text and combine functions
                            flag functionazied in temp data is in case user changes scenes several times.
                            instead of going over it again and again, transform it once, and check flag.
                            Although, now that i think about it, MODVAR also keeps it as a simple list.....
                            so probably need to change how it is saved in MODVAR and later when saving to file"""
                            if selected_scene_to_load in SimpleFields.mod_temp_data.mod_data['events'][SimpleFields.mod_temp_data.current_editing_event]['Functionized']:
                                if not SimpleFields.mod_temp_data.mod_data['events'][SimpleFields.mod_temp_data.current_editing_event]['Functionized'][selected_scene_to_load]:
                                    self.functionize(scene_data[data])
                                    SimpleFields.mod_temp_data.mod_data['events'][SimpleFields.mod_temp_data.current_editing_event]['Functionized'][selected_scene_to_load] = 1
                            else:
                                SimpleFields.mod_temp_data.mod_data['events'][
                                    SimpleFields.mod_temp_data.current_editing_event]['Functionized'][
                                    selected_scene_to_load] = 1
                                self.functionize(scene_data[data])
                            self.display_data.add_data(scene_data[data])
                        else:
                            self.data_fields[data].set_val(scene_data[data])
                    break
        else:
            return

    def functionize(self, scene_data=[]):
        """here, go over list of string of scene data, compare each to functions
        if found function, check amount/type of steps and turn it into a dictionary"""
        tagging_no = 0
        verse_idx = 0
        f_end = 'EndLoop'
        while verse_idx < len(scene_data):
            temp = {}
            if tagging_no == 0:
                """first add verse to scene display. Then check if its a functions or not"""
                if scene_data[verse_idx].find(' ') < 0:
                    """if there is no space, it might be a functions. Or it's just a 1 word sentence"""
                    tagging_no = GlobalVariables.Glob_Var.function_steps_no(function_name=scene_data[verse_idx])
                    """if tagging no was returned, then its functions, add tag"""
                    if tagging_no:
                        if isinstance(tagging_no, str):
                            """if its string, then its either endloop or endmusic, so write in off and change to -1
                            there will be issues with some unique functions like AddMonsterToEncounter,
                            which has optional fields and no endloop"""
                            f_end = tagging_no
                            if tagging_no == 'check':
                                tagging_no = 1
                            else:
                                tagging_no = -1
                        f_title = scene_data.pop(verse_idx)  #poping skips laters
                    else:
                        verse_idx += 1
                else:
                    verse_idx += 1
            else:
                temp[f_title] = []
                """if tagging no is greater then 0, then now its attributes to add"""
                if tagging_no > 0:
                    if f_end == 'check':
                        """also, there are some function with optional fields which are not empty, so number of attributes
                        is changing, here will be specialized"""
                        if f_title == 'AddMonsterToEncounter':
                            next_attribute = scene_data[verse_idx]
                            if next_attribute == 'ChangeForm':
                                tagging_no = 2
                            else:
                                tagging_no = 1
                        elif f_title == 'PlayMotionEffectCustom':
                            """ first check if effect is empty
                                "", "Character", "Aiko", "0", "0"
                                "", "Bodypart", "Aiko", "Expression", "0", "0"
                                first check 3 value, if there is a 0, its 4 fields, if not, its 5"""
                            if not scene_data[verse_idx]:
                                next_attribute = scene_data[verse_idx+3]
                                if next_attribute == '0':
                                    tagging_no = 4
                                else:
                                    tagging_no = 5
                            else:
                                """ "Bounce", "Characters", "1.0", "15"
                                    "Ride", "Bodypart", "Aiko", "Expression", "0.5", "10"
                                    first check third value, if there is a dot, there is 1 more, if not
                                    check if value earlier got dot, if not, its 2 more, if yes, its just 4 fields"""
                                next_attribute = scene_data[verse_idx+3]
                                if '.' in next_attribute:
                                    tagging_no = 5
                                else:
                                    prev_attribute = scene_data[verse_idx+2]
                                    if '.' in prev_attribute:
                                        tagging_no = 4
                                    else:
                                        tagging_no = 6
                    while tagging_no > 0:
                        temp[f_title].append(scene_data.pop(verse_idx))
                        tagging_no -= 1
                elif tagging_no < 0:
                    """here is when there is endloop among attributes
                    if tagging is -1 it means endloop is last. is less, then it need to count values after"""
                    tags_verse = f_end
                    while tags_verse:
                        attribute = scene_data.pop(verse_idx)
                        temp[f_title].append(attribute)
                        if attribute == f_end:
                            tags_verse = 'End'
                        if tags_verse == 'End':
                            tagging_no += 1
                        if tagging_no == 0:
                            tags_verse = ''
                scene_data.insert(verse_idx, temp)
                verse_idx += 1

    def test(self):
        temp = self.area_input.textCursor()
        print(temp.selectionStart())
        print(temp.selectionEnd())
        print(temp.selectedText())