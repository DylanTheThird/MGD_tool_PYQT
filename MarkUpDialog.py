# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'VisualOptions.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
import SimpleFields
import GlobalVariables
from Function_class import Function_Gui
from otherFunctions import wrap, show_message

class area_mark_up(SimpleFields.AreaEntry):
    def __init__(self):
        super().__init__(edit=False)
        """if opening from event, it should add text to display field. but if opening from simple text field
        it should probably not do anything"""
        self.return_target = None
        """if doubleclicked on treeview, then update current text"""
        self.flag_update = False

    def keyPressEvent(self, event: QtGui.QKeyEvent):
        if self.return_target:
            if event.key() == QtCore.Qt.Key_Return:
                self.add_verse()
                return
            elif event.key() == QtCore.Qt.Key_Escape:
                self.clear_val()
                self.flag_update = False
        super().keyPressEvent(event)

    def add_verse(self):
        text = wrap(self.get_val(), length=50)
        if text:
            if self.flag_update:
                self.return_target.update_leaf(text)
                self.flag_update = False
            elif self.return_target.selected_element():
                """if already selected something, then insert above it"""
                self.return_target.insert_row([text])
            else:
                self.return_target.add_data(data=text)
            self.clear_val()
    def insert_text(self, text):
        """insert value where cursor is."""
        self.insertPlainText(text)
    def mark_text(self, beg, end):
        cursor = self.textCursor()
        new_text = beg + cursor.selectedText() + end
        self.insertPlainText(new_text)
        # print("Selection start: %d end: %d" %
        #       (cursor.selectionStart(), cursor.selectionEnd()))
# class CustomLabel(QtWidgets.QLabel):
#     # doubleClicked = pyqtSignal()
#     def __init__(self, master, label_text):
#         super().__init__(parent=master, text=label_text)
#         self.setAlignment(QtCore.Qt.AlignRight)
#
#     def update_label(self, new_label):
#         self.setText(new_label)
#
#     def change_position(self, position='C/L/R'):
#         if position == 'C':
#             self.setAlignment(QtCore.Qt.AlignCenter)
#         elif position == 'L':
#             self.setAlignment(QtCore.Qt.AlignLeft)
#         elif position == 'R':
#             self.setAlignment(QtCore.Qt.AlignRight)
#
#     def change_background_color(self):
#         self.setStyleSheet("background-color: red")
#     def clear_color(self):
#         self.setStyleSheet("")
#
# class UniqueView_scene(QtWidgets.QListView):
#     def __init__(self, master, field_title=None, class_connector=None, data_treeview=None):
#         super().__init__(parent=master)
#         self.connector_to_outside_complex_class = class_connector
#         self.type = 'multilist'
#         self.tree_model = QStandardItemModel()
#         self.setSelectionMode(QAbstractItemView.ExtendedSelection)
#         self.model_index = QtCore.QModelIndex()
#         self.setModel(self.tree_model)
#         self.setMaximumSize(160, 100)
#         self.setMinimumHeight(50)
#         self.setFixedHeight(20)
#         self.flag_edit = True
#         self.treeview_with_main_and_mod_data = data_treeview
#
#     def set_val(self, node=None, data=[]):
#         # example data ['file',{'folder ':['file']}]
#         if not node:
#             # node = self.rootnode
#             node = self.tree_model
#         else:
#             if isinstance(node, str):
#                 node = self.find_node(node)
#                 node = self.tree_model.itemFromIndex(node)
#         for values in data:
#             if isinstance(values, dict):
#                 for keys in values:
#                     parent_row = QStandardItem()
#                     parent_row.setText(keys)
#                     if self.flag_folders:
#                         parent_row.setEditable(False)
#                     node.appendRow(parent_row)
#                     self.add_data(parent_row, values[keys])
#             else:
#                 bottom_row = QStandardItem()
#                 bottom_row.setText(values)
#                 if not self.flag_child_editable:
#                     bottom_row.setEditable(False)
#                 node.appendRow(bottom_row)
#
#     def clear_val(self):
#         self.tree_model.clear()
#         self.setFixedHeight(20)
#     def add_data(self, node=None, data=[]):
#         # example data ['file',{'folder ':['file']}]
#         if not node:
#             # node = self.rootnode
#             node = self.tree_model
#         else:
#             if isinstance(node, str):
#                 node = self.find_node(node)
#                 node = self.tree_model.itemFromIndex(node)
#         if isinstance(data, list):
#             for values in data:
#                 self.add_data(node, values)
#         elif isinstance(data, dict):
#             for key in data:
#                 parent_row = QStandardItem()
#                 parent_row.setText(key)
#                 parent_row.setEditable(False)
#                 node.appendRow(parent_row)
#                 self.add_data_to_display(parent_row, data[key])
#         else:
#             """if data is just string"""
#             bottom_row = QStandardItem()
#             bottom_row.setText(data)
#             bottom_row.setEditable(False)
#             node.appendRow(bottom_row)
#             if self.height() < 100:
#                 self.setFixedHeight(self.height() + 20)
#         # if not node:
#         #     # node = self.rootnode
#         #     node = self.tree_model
#         # else:
#         #     if isinstance(node, str):
#         #         node = self.find_node(node)
#         #         node = self.tree_model.itemFromIndex(node)
#         # for values in data:
#         #     if isinstance(values, dict):
#         #         for keys in values:
#         #             parent_row = QStandardItem()
#         #             parent_row.setText(keys)
#         #             if self.flag_folders:
#         #                 parent_row.setEditable(False)
#         #             node.appendRow(parent_row)
#         #             self.add_data(parent_row, values[keys])
#         #     else:
#         #         bottom_row = QStandardItem()
#         #         bottom_row.setText(values)
#         #         bottom_row.setEditable(False)
#         #         node.appendRow(bottom_row)
#         if self.flag_edit:
#             GlobalVariables.Glob_Var.edited_field()
#     def keyPressEvent(self, event: QtGui.QKeyEvent):
#         if event.key() == Qt.Key_Delete:
#             # self.delete_leaf()
#             self.delete()
#     def delete(self):
#         selected_items_idx = self.selectedIndexes()
#         selected_items = []
#         for idx in selected_items_idx:
#             selected_items.append(self.tree_model.itemFromIndex(idx))
#         for items in selected_items:
#             item = self.tree_model.indexFromItem(items)
#             self.tree_model.removeRow(item.row(), item.parent())
#             if self.height() > 20:
#                 self.setFixedHeight(self.height() - 20)
#     def destroy(self):
#         for idx in range(self.custom_layout.count()):
#             temp = self.custom_layout.takeAt(0)
#             self.custom_layout.removeWidget(temp.widget())
#             temp.widget().deleteLater()
#     def get_data(self, parent_index=None, root_list=None):
#         """stuff are in a list, where file should be strings, while folders should be dict
#         should return something like [row0, row1, {row2:[row20, row21]},[row3column0, row3column1]}"""
#         if parent_index:
#             row_range = self.tree_model.rowCount(parent_index)
#             col_range = self.tree_model.columnCount(parent_index)
#         else:
#             row_range = self.tree_model.rowCount()
#             col_range = self.tree_model.columnCount()
#         current_row_folder = {}
#         rows_list = []
#         ix = None
#         for i in range(row_range):
#             cols_list = []
#             for ii in range(col_range):
#                 if parent_index:
#                     row_index = self.tree_model.index(i, ii, parent_index)
#                 else:
#                     row_index = self.tree_model.index(i, ii)
#                 self.get_data(row_index, cols_list)
#             # here i would have to check if other columns are empty, if yes, turn cols_list into a string
#             for vals in cols_list:
#                 if not vals:
#                     cols_list.remove(vals)
#             if len(cols_list) == 1:
#                 rows_list.append(cols_list[0])
#             else:
#                 rows_list.append(cols_list)
#             if parent_index:
#                 current_row_folder[parent_index.data()] = rows_list
#         if current_row_folder:
#             root_list.append(current_row_folder)
#         else:
#             if parent_index:
#                 root_list.append(parent_index.data())
#             else:
#                 return rows_list
#     def focusInEvent(self, event):
#         """when clicked on widget, connect it to main multilist, where it filters appropiate items to select and add"""
#         if self.connector_to_outside_complex_class:
#             # GlobalVariables.Glob_Var.main_game_field.connect_multilist(self.connector_to_outside_complex_class)
#             self.treeview_with_main_and_mod_data.connect_multilist(self.connector_to_outside_complex_class)
#         else:
#             # GlobalVariables.Glob_Var.main_game_field.disconnect_multilist()
#             self.treeview_with_main_and_mod_data.disconnect_multilist()
#         super().focusInEvent(event)
# class SimpleEntry_scene(QtWidgets.QLineEdit):
#     def __init__(self, master_widget, field_name=None, field_data=None, template_name=None, class_connector=None
#                  , edit=True, main_data_treeview=None, label_pos='H'):
#         super().__init__(parent=master_widget)
#         if label_pos == 'H':
#             self.custom_layout = QtWidgets.QHBoxLayout()
#             self.custom_layout.setAlignment(QtCore.Qt.AlignCenter)
#         else:
#             self.custom_layout = QtWidgets.QVBoxLayout()
#             self.custom_layout.setAlignment(QtCore.Qt.AlignCenter)
#         if field_name:
#             # if len(field_name) < 2:
#             if isinstance(field_name, int):
#                 field_name = 'Amount'
#             self.label_custom = CustomLabel(master_widget, field_name)
#             self.custom_layout.addWidget(self.label_custom)
#         self.custom_layout.addWidget(self)
#         self.template_name = template_name
#         self.title = field_name
#         self.type = 'text'
#         self.old_value = ''
#         self.default_value = ''
#         self.addition = False
#         self.setMinimumWidth(70)
#         self.setMaximumWidth(220)
#         self.row_size = 1
#         """this is for multilist display. in case multilist class accepts only 1 value, no points in making entire tree.
#         so intead, just make simple text field, which is created in another class"""
#         self.connector_to_outside_complex_class = class_connector
#         self.treeview_with_main_and_mod_data = main_data_treeview
#         if field_data:
#             if 'tooltip' in field_data:
#                 self.setToolTip(field_data['tooltip'])
#             if 'default' in field_data:
#                 self.default_value = field_data['default']
#             if 'options' in field_data:
#                 if 'addition' in field_data['options']:
#                     self.addition = True
#
#         # self.temp_master = master
#         self.shortcuts = []
#         self.setObjectName('entry')
#         if edit:
#             self.field_modified_check()
#
#     def clear_val(self):
#         self.clear()
#
#     def cancel(self):
#         self.setReadOnly(True)
#         return
#
#     def get_val(self, temp_dict_container=None):
#         return_val = self.text()
#         if return_val == "":
#             return_val = self.default_value
#         if temp_dict_container is not None:
#             temp_dict_container[self.title] = return_val
#         else:
#             return return_val
#
#     def set_val(self, new_value):
#         self.setText(new_value)
#
#     def set_up_widget(self, outside_layout, insert_for_optional=False):
#         """insert for optional is mostly for optional fields to insert widget before last stretch"""
#         if insert_for_optional:
#             outside_layout.insertLayout(outside_layout.count()-1, self.custom_layout)
#             # outside_layout.insertWidget(outside_layout.count()-1, self.custom_layout)
#         else:
#             outside_layout.addLayout(self.custom_layout)
#
#     # def set_up_shortcut(self, sequence, function):
#     #     shortcut = QtWidgets.QShortcut(QtGui.QKeySequence(sequence), self)
#     #     shortcut.activated.connect(function)
#     #     self.shortcuts.append(shortcut)
#
#     # if field is in complex class and should allow access to main items, connector will be created. it should
#     #  be passed to main game field. If fields does not have access, connector is NONE, so should disconnect main field
#     def focusInEvent(self, event):
#         if self.connector_to_outside_complex_class and self.treeview_with_main_and_mod_data:
#             # GlobalVariables.Glob_Var.main_game_field.connect_multilist(self.connector_to_outside_complex_class)
#             self.treeview_with_main_and_mod_data.connect_multilist(self.connector_to_outside_complex_class)
#         else:
#             # GlobalVariables.Glob_Var.main_game_field.disconnect_multilist()
#             if self.treeview_with_main_and_mod_data:
#                 self.treeview_with_main_and_mod_data.disconnect_multilist()
#         super().focusInEvent(event)
#
#     def field_modified_check(self):
#         self.textChanged.connect(GlobalVariables.Glob_Var.edited_field)
#
#     def function_on_modify(self, function=None):
#         self.textChanged.connect(function)
#
#     def destroy(self):
#         for idx in range(self.custom_layout.count()):
#             temp = self.custom_layout.takeAt(0)
#             self.custom_layout.removeWidget(temp.widget())
#             temp.widget().deleteLater()
#     def center(self):
#         self.setAlignment(QtCore.Qt.AlignCenter)
#     # def focusOutEvent(self, event):
#     #     print('event-focus-out:', self.objectName())
#     #     super().focusOutEvent(event)
# class MultiListDisplay_scene:
#     """there are 3 types of data here.
#     single item - only 1 item allowed, so it could be an input field, where you can type text to autosearch for
#      available values from main multilist, also limited to type of items to seachs
#     several items - this allows several items with no duplication. will be a treeview and maybe add something like above
#     multiple items - several with duplicates."""
#     def __init__(self, master=None, field_name=None,
#                  field_data=None, template_name=None, main_data_treeview=None):
#         self.title = field_name
#         self.type = 'multilist'
#         self.template_name = template_name
#         self.label_custom = CustomLabel(master, field_name)
#         # self.label_custom = custom_button(master, field_name)
#         self.addition = False
#         self.row_size = 4
#         # field_data = {'options':['unique'], 'choices':['Items']}
#         if 'options' in field_data:
#             if 'single_item' in field_data['options']:
#                 self.version = 'single'
#                 self.row_size = 1
#             elif 'unique' in field_data['options']:
#                 self.version = 'unique'
#             else:
#                 self.version = 'multi_item'
#             if 'addition' in field_data['options']:
#                 self.addition = True
#         if 'tooltip' in field_data:
#             self.label_custom.setToolTip(field_data['tooltip'])
#         # self.label_custom.change_position('center')
#         # self.label_custom.button_transform()
#         self.field_frame = master
#         self.selection_type = ''
#         if 'choices' in field_data:
#             for choice in field_data['choices']:
#                 if 'Items' in choice:
#                     self.selection_type += 'Items'
#                 elif 'Skills' in choice:
#                     self.selection_type += 'Skills'
#                 elif 'Perks' in choice:
#                     self.selection_type += 'Perks'
#                 elif 'Monsters' in choice:
#                     self.selection_type += 'Monsters'
#                 elif 'Fetishes' in choice:
#                     self.selection_type += 'Fetishes Addictions'
#                 else:
#                     self.selection_type += choice
#                     # self.selection_type += field_data['choices'][0]
#         """
#         unique - can add multiple items, cannot duplicate
#         multi_item - items can be duplicated
#         single_item - can only select 1 item
#         """
#         self.custom_layout = QtWidgets.QVBoxLayout()
#         if self.version == 'single':
#             self.final_data = SimpleEntry(master, None, class_connector=self, main_data_treeview=main_data_treeview)
#             self.label_custom.change_position('R')
#             self.custom_layout = QtWidgets.QHBoxLayout()
#             self.custom_layout.setAlignment(QtCore.Qt.AlignCenter)
#         elif self.version == 'unique':
#             # self.final_data = QtWidgets.QListWidget(parent=master)
#             self.final_data = UniqueView(master=master, class_connector=self, data_treeview=main_data_treeview)
#             self.label_custom.change_position('center')
#         else:
#             self.final_data = UniqueView(master=master, class_connector=self, data_treeview=main_data_treeview)
#             # self.final_data = ElementsList(master, field_name, class_connector=self)
#             self.label_custom.change_position('center')
#         self.custom_layout.addWidget(self.label_custom)
#         self.custom_layout.addWidget(self.final_data)
#         self.custom_layout.addStretch(1)
#
#             # self.set_row_size(6)
#             # self.data_tree = ElementsList(self, 3, 0, 'Double Click to Edit', colspan=3, treeview_height=3)
#             # self.data_tree.treeview.configure(selectmode='extended')
#             # self.data_tree.treeview.bind("<Double-Button-1>", self.on_double_click_edit_field)
#             # self.data_tree.treeview.unbind("<Delete>")
#             # self.data_tree.treeview.unbind("<Control_L>")
#         # self.label_custom.doubleClicked.connect(self.edit_value)
#         # self.label_custom.doubleClicked.connect(self.edit_value)
#         # self.label_custom.clicked.connect(self.edit_value)
#
#     def set_val(self, values):
#         if self.version == 'single':
#             self.final_data.set_val(values)
#         else:
#             if self.version == 'unique':
#                 if isinstance(values, str):
#                     values = [values]
#                 current_count = self.final_data.tree_model.rowCount()
#                 current_values = []
#                 for idx in range(current_count):
#                     item = self.final_data.tree_model.item(idx)
#                     current_values.append(item.text())
#                 for value in values:
#                     if value not in current_values:
#                         # self.final_data.addItem(value)
#                         self.final_data.add_data('',[value])
#             #             TODO maybe add warning?
#             else:
#                 self.final_data.add_data(data=[values])
#     def get_val(self, temp_dict_container=None):
#         # if self.version == 'single':
#         #     temp = self.var.get()
#         #     if 'CLICK' in temp:
#         #         temp = ''
#         # else:
#         #     temp = []
#         #     all_vals = self.data_tree.treeview.get_children()
#         #     for value in all_vals:
#         #         temp.append(self.data_tree.treeview.item(value)['text'])
#         #     # this might be important if there is a problem with values returned somewhere
#         #     # if len(temp) == 0:
#         #     #     temp.append('')
#         if self.version == 'single':
#             return_data = self.final_data.get_val()
#         elif self.version == 'unique':
#             return_data = []
#             current_count = self.final_data.count()
#             for idx in range(current_count):
#                 item = self.final_data.item(idx)
#                 return_data.append(item.text())
#         else:
#             return_data = self.final_data.get_data()
#         if temp_dict_container is not None:
#             temp_dict_container[self.title] = return_data
#         else:
#             return return_data
#
#     def clear_val(self):
#         if self.version == 'unique':
#             self.final_data.clear()
#         else:
#             self.final_data.clear_val()
#     def hide(self):
#         self.label_custom.hide()
#         self.final_data.hide()
#     def show(self):
#         self.final_data.show()
#         if self.label_custom.text():
#             self.label_custom.show()
#     def edit_value(self):
#         # this is for editing in new window
#         print('test edit value miltilist)')
#         item_win = QtWidgets.QDialog(parent=self.field_frame)
#         item_visual = MainGameItemsInNewWindow()
#         item_visual.setupUi(Dialog=item_win)
#         item_win.show()
#     def destroy(self):
#         # self.custom_layout.deleteLater()
#         for idx in range(self.custom_layout.count()):
#             temp = self.custom_layout.takeAt(0)
#             self.custom_layout.removeWidget(temp.widget())
#             if temp:
#                 if not isinstance(temp, QtWidgets.QSpacerItem):
#                     temp.widget().deleteLater()
#         self.custom_layout.deleteLater()
#     def set_up_widget(self, outside_layout, insert_for_options=False):
#         if insert_for_options:
#             outside_layout.insertLayout(outside_layout.count() - 1, self.custom_layout)
#         else:
#             outside_layout.addLayout(self.custom_layout)
#         outside_layout.setAlignment(self.custom_layout,QtCore.Qt.AlignCenter)


class MarkUp_Window(QtWidgets.QWidget):
    def __init__(self, target_field=None, scenes_flag=None, data_for_functions=None, current_scene_list=None,
                 scene_data=None, quick_load_scene=None):
        super().__init__()
        """target field - either treeview for scenes or text field for some fields that allow markups
        scenes_flag - if textfied is target, no need to display treeview for scenes"""
        self.setWindowTitle('Events')
        # Dialog.resize(310, 299)
        # self.widget.setGeometry(QtCore.QRect(0, 10, 301, 281))
        self.setObjectName("FunctionWin")
        self.resize(900, 500)

        self.v_main_layout = QtWidgets.QVBoxLayout(self)
        self.v_main_layout.setContentsMargins(0, 0, 0, 0)
        self.v_main_layout.setObjectName("mainLayout")
        self.setLayout(self.v_main_layout)


        v_layout_buttons = QtWidgets.QHBoxLayout()
        v_layout_buttons.setObjectName("button_layout")
        self.mark_up_buttons_background_player = QtWidgets.QWidget()
        self.mark_up_buttons_background_text = QtWidgets.QWidget()
        # v_layout_buttons.addWidget(self.mark_up_buttons_background_player)
        # v_layout_buttons.addWidget(self.mark_up_buttons_background_text)
        self.prepare_markup_buttons()
        """all the buttons for markups here"""
        # placeholder_buttons = SimpleFields.CustomButton(self, 'placeholder width')
        # # placeholder_buttons.clicked.connect(lambda: self.change_size(1))
        # placeholder_buttons.clicked.connect(self.test)
        # placeholder_buttons2 = SimpleFields.CustomButton(self, 'placeholder2 heigh')
        # placeholder_buttons2.clicked.connect(lambda: self.change_size(2))
        # h_layout_buttons.addWidget(placeholder_buttons)
        # h_layout_buttons.addWidget(placeholder_buttons2)
        # self.v_main_layout.addLayout(v_layout_buttons)
        self.v_main_layout.addWidget(self.mark_up_buttons_background_player)
        self.v_main_layout.addWidget(self.mark_up_buttons_background_text)

        """main data. Area text for input and treeview for display on the left
        checkboxes, treeview for functions and functions creation on right"""
        """first, vertical, contains area text and treeview"""
        # v_layout_main_input = QtWidgets.QVBoxLayout()
        # v_layout_main_input.setObjectName("main_input_layout")
        # self.text_test = SimpleFields.SimpleEntry(self)
        # self.text_test.set_up_widget(self.v_main_layout)
        # self.area_input = SimpleFields.AreaEntry(self, edit=False)
        self.area_input = area_mark_up()
        self.area_input.setMaximumSize(800, 100)
        self.area_input.set_up_widget(self.v_main_layout)
        """now, display data on the left and on the right, checkboxes and functions gui"""
        """on the left is treeview for data from input, hidden scene list and hidden scene data.
        on the right area with explanation, treeview with functions and 2 buttons"""
        h_layout_display_f_gui = QtWidgets.QHBoxLayout()

        # v_layout_left_side = QtWidgets.QVBoxLayout()
        # h_layout_display_f_gui.addLayout(v_layout_left_side)

        v_layout_left_side = QtWidgets.QVBoxLayout()

        self.target_field = target_field
        if current_scene_list:
            self.current_scenes = current_scene_list
            self.functions_list = list(GlobalVariables.Glob_Var.functions_data.keys())
        else:
            self.current_scenes = None
        if scenes_flag:
            """first horizontal to put buttons at the top"""
            h_lay_scene_buttons = QtWidgets.QHBoxLayout()
            self.button_display_scenes = SimpleFields.CustomButton(None, 'Scenes')
            self.button_display_scenes.setMaximumWidth(100)
            self.button_display_scenes.clicked.connect(self.display_scene_list)
            h_lay_scene_buttons.addWidget(self.button_display_scenes)
            self.button_display_scenes_data = SimpleFields.CustomButton(None, 'Data')
            self.button_display_scenes_data.setMaximumWidth(100)
            self.button_display_scenes_data.clicked.connect(self.switch_to_data)
            self.flag_data = False
            h_lay_scene_buttons.addWidget(self.button_display_scenes_data)
            self.button_load_function = SimpleFields.CustomButton(None, '>>')
            self.button_load_function.setMaximumWidth(100)
            self.button_load_function.clicked.connect(self.load_function)
            h_lay_scene_buttons.addWidget(self.button_load_function)
            """now add horizontal, to put scene list and scene text next to each other.
            Also, so I dont have to resize them each time, put it on a background widget"""
            h_layout_display = QtWidgets.QHBoxLayout()
            self.display_scene_widget_background = QtWidgets.QWidget()
            # self.display_scene_widget_background.setMaximumWidth(400)
            # self.display_scene_widget_background.setFixedWidth(400)
            # sp = self.display_scene_widget_background.sizePolicy()
            # sp.setHorizontalPolicy(QtWidgets.QSizePolicy.Expanding)
            # self.display_scene_widget_background.setSizePolicy(sp)
            temp_lay = QtWidgets.QHBoxLayout()
            self.display_scene_widget_background.setLayout(temp_lay)
            h_layout_display.addWidget(self.display_scene_widget_background)
            # v_layout_display.addLayout(h_layout_display)
            self.scene_list = SimpleFields.ElementsList(self, search_field=True)
            """since this scene list is basicly same as in function field in main view, instead to duplicatind
            data and after done making a copy, I passed tree models and assigned them here.
            This way any changes should be reflected in both treeviews.
            added if for testing"""
            if target_field:
                self.scene_list.tree_model = self.target_field.tree_model
                self.scene_list.sorting = self.target_field.sorting
                self.scene_list.setModel(self.scene_list.sorting)
            else:
                temp = {}
                if self.current_scenes:
                    for event_type in self.current_scenes:
                        templist = []
                        for scene_name in self.current_scenes[event_type]:
                            templist.append(scene_name)
                        temp[event_type] = templist
                    self.scene_list.add_data(temp)
            self.scene_list.set_up_widget(temp_lay)
            self.scene_list.hide()
            self.scene_list.doubleClicked.connect(self.load_scene_to_display)
            """hidden setup of basic scene data"""
            v_layout_display_scene_data = QtWidgets.QVBoxLayout()
            self.scene_data_widget_background = QtWidgets.QWidget()
            self.scene_data_widget_background.setLayout(v_layout_display_scene_data)
            h_layout_display.addWidget(self.scene_data_widget_background)
            """first, clean it to make it easier"""
            self.data_fields = []
            self.data_fields = {}
            """this temp mainfield is created later as part of function gui field.
             also, needs to show it, as normally is hidden"""
            self.flag_main_data = False
            """creating fields for scene data moved later, after function gui is created. to save space
            for monster, some fields are connected to fields created in functions gui"""
            # TODO problem is with multilist, they should connect to main treeview, but only main treeview here is created later as part of functions gui
            # if scene_data:
            #     for data_field in scene_data:
            #         for field in scene_data[data_field]:
            #             if field != 'theScene':
            #                 """the scene is created separately in main view, other fields are in hidden view"""
            #                 self.data_fields[field] = scene_data[data_field][field]
            #     for fieldname in self.data_fields:
            #         """now, same as in custome fields, create appropiate fields"""
            #         if self.data_fields[fieldname]["type"] == "text":
            #             tempfield = SimpleFields.SimpleEntry(master_widget=self.scene_data_widget_background, field_name=fieldname,
            #                                                  field_data=self.data_fields[fieldname],
            #                                                  main_data_treeview=temp_mainfield_data, label_pos='V')
            #         elif self.data_fields[fieldname]["type"] == "int":
            #             tempfield = SimpleFields.NumericEntry(master=self.scene_data_widget_background, wid=4, field_name=fieldname,
            #                                                   field_data=self.data_fields[fieldname])
            #         elif self.data_fields[fieldname]["type"] == "singlelist":
            #             field_optionbox = SimpleFields.SingleList(self.scene_data_widget_background, fieldname, self.data_fields[fieldname])
            #             # field_optionbox.configure(takefocus=1)
            #             tempfield = field_optionbox
            #         elif self.data_fields[fieldname]["type"] == "filePath":
            #             tempfield = SimpleFields.FileField(self.scene_data_widget_background, fieldname, field_data=self.data_fields[fieldname])
            #         elif self.data_fields[fieldname]["type"] == 'area':
            #             tempfield = SimpleFields.AreaEntry(self.scene_data_widget_background, fieldname)
            #         elif self.data_fields[fieldname]["type"] == 'multilist':
            #             tempfield = SimpleFields.MultiListDisplay(self.scene_data_widget_background, fieldname, self.data_fields[fieldname],
            #                                                       main_data_treeview=temp_mainfield_data)
            #             self.flag_main_data = True
            #         self.data_fields[fieldname] = tempfield
            #         tempfield.set_up_widget(v_layout_display_scene_data)
            #         # v_layout_display_scene_data.addWidget(tempfield)
            self.scene_data_widget_background.hide()
            # h_layout_display.addWidget(self.scene_data_widget_background)
            """here is display data. is where iines and functions for scene are displayed and can be modified"""
            self.display_data = SimpleFields.ElementsList(self, "Event text")
            # self.display_data.setMaximumSize(600, 350)
            self.display_data.parent_tag = 'function'
            self.display_data.setMinimumWidth(100)
            self.display_data.setMinimumWidth(300)
            self.display_data.set_up_widget(h_layout_display)
            self.display_data.doubleClicked.connect(self.update_row)
            # self.data_fields['theScene'] = self.display_data
            # h_layout_display_f_gui.addLayout(H_layout_display)
            v_layout_left_side.addLayout(h_lay_scene_buttons)
            v_layout_left_side.addLayout(h_layout_display)
        else:
            self.scene_list = None
            self.display_data = None
            self.scene_button = None

        v_layout_right_side = QtWidgets.QVBoxLayout()
        h_layout_display_f_gui.addLayout(v_layout_left_side)
        h_layout_display_f_gui.addLayout(v_layout_right_side)
        """layout for functions field creations, already added"""
        self.v_layout_function_fields = QtWidgets.QVBoxLayout()
        self.v_layout_function_fields.setObjectName('function_fields_layout')
        h_layout_display_f_gui.addLayout(self.v_layout_function_fields)
        h_layout_display_f_gui.addStretch(1)
        # """2 checkboxes, determine how to add functions"""
        # h_lay_checkboxes = QtWidgets.QHBoxLayout()
        # self.checkbox_text = SimpleFields.CheckBox(self, 'TEXT', 't')
        # self.checkbox_text.set_up_widget(h_lay_checkboxes)
        # self.checkbox_event = SimpleFields.CheckBox(self, 'EVENT', 'e')
        # self.checkbox_event.set_up_widget(h_lay_checkboxes)
        # self.button_group = QtWidgets.QButtonGroup()
        # self.button_group.addButton(self.checkbox_text)
        # self.button_group.addButton(self.checkbox_event)
        # self.button_group.buttonToggled.connect(self.on_checkbox_toggled)
        # """flag function will be list. first its a 0/1, second, target field"""
        # self.flag_function_target_type = []
        # if not scenes_flag:
        #     self.checkbox_event.setEnabled(False)
        #     self.checkbox_text.set_val(True)
        #     self.checkbox_event.setEnabled(False)
        # h_lay_checkboxes.setAlignment(QtCore.Qt.AlignCenter)
        # v_layout_right_side.addLayout(h_lay_checkboxes)
        """functions gui"""
        if scenes_flag:
            config_list = [1, self.area_input, self.display_data]
        else:
            config_list = [0, self.area_input, None]
        self.functions = Function_Gui(None, None, self, fields_lay=self.v_layout_function_fields,
                                      adding_config=config_list, scene_list=current_scene_list)
        self.functions.set_up_widget(v_layout_right_side)

        """now create fields for scene data, so it has access to functions gui main data tree
        moved from above"""
        if scene_data:
            for data_field in scene_data:
                for field in scene_data[data_field]:
                    if field != 'theScene':
                        """the scene is created separately in main view, other fields are in hidden view"""
                        self.data_fields[field] = scene_data[data_field][field]
            for fieldname in self.data_fields:
                """now, same as in custome fields, create appropiate fields"""
                if self.data_fields[fieldname]["type"] == "text":
                    tempfield = SimpleFields.SimpleEntry(master_widget=self.scene_data_widget_background,
                                                         field_name=fieldname,
                                                         field_data=self.data_fields[fieldname],
                                                         main_data_treeview=self.functions.treeview_main_game_items, label_pos='V')
                    tempfield.label_custom.change_position('C')
                elif self.data_fields[fieldname]["type"] == "int":
                    tempfield = SimpleFields.NumericEntry(master=self.scene_data_widget_background, wid=4,
                                                          field_name=fieldname,
                                                          field_data=self.data_fields[fieldname])
                elif self.data_fields[fieldname]["type"] == "singlelist":
                    field_optionbox = SimpleFields.SingleList(self.scene_data_widget_background, fieldname,
                                                              self.data_fields[fieldname])
                    # field_optionbox.configure(takefocus=1)
                    tempfield = field_optionbox
                elif self.data_fields[fieldname]["type"] == "filePath":
                    tempfield = SimpleFields.FileField(self.scene_data_widget_background, fieldname,
                                                       field_data=self.data_fields[fieldname])
                elif self.data_fields[fieldname]["type"] == 'area':
                    tempfield = SimpleFields.AreaEntry(self.scene_data_widget_background, fieldname)
                elif self.data_fields[fieldname]["type"] == 'multilist':
                    tempfield = SimpleFields.MultiListDisplay(self.scene_data_widget_background, fieldname,
                                                              self.data_fields[fieldname],
                                                              main_data_treeview=self.functions.treeview_main_game_items)
                    self.flag_main_data = True
                self.data_fields[fieldname] = tempfield
                tempfield.set_up_widget(v_layout_display_scene_data)
                # v_layout_display_scene_data.addWidget(tempfield)
            v_layout_display_scene_data.addStretch(1)
            self.data_fields['theScene'] = self.display_data
        """here ends cut in of fields creation"""

        self.v_layout_function_fields.addStretch(1)
        # """second, 2 checkboxes for adding function to text of event and now the hard part, whole functionality"""
        # h_lay_functions_main = QtWidgets.QHBoxLayout()
        # h_lay_functions_main.setObjectName('functions_layout_main')
        # v_layout_function_window = QtWidgets.QVBoxLayout()
        # v_layout_function_window.setObjectName('function_window_layout')
        # h_lay_checkboxes = QtWidgets.QHBoxLayout()
        # self.checkbox_text = SimpleFields.CheckBox(self, 'text', 't')
        # self.checkbox_text.set_up_widget(h_lay_checkboxes)
        # self.checkbox_event = SimpleFields.CheckBox(self, 'event', 'e')
        # self.checkbox_event.set_up_widget(h_lay_checkboxes)
        # self.flag_function_target_type = None
        # v_layout_function_window.addLayout(h_lay_checkboxes)
        self.v_main_layout.addLayout(h_layout_display_f_gui)
        h_final_buttons_layout = QtWidgets.QHBoxLayout()
        but_save = SimpleFields.CustomButton(None, 'SAVE')
        but_save.setMaximumWidth(100)
        but_save.clicked.connect(self.save_data)
        h_final_buttons_layout.addWidget(but_save)
        but_cancel = SimpleFields.CustomButton(None, 'CANCEL/NEW')
        but_cancel.setMaximumWidth(100)
        but_cancel.clicked.connect(self.cancel_scene)
        h_final_buttons_layout.addWidget(but_cancel, alignment=QtCore.Qt.AlignCenter)
        but_done = SimpleFields.CustomButton(None, '!!DONE!!')
        but_done.setMaximumWidth(100)
        but_done.clicked.connect(self.done)
        h_final_buttons_layout.addWidget(but_done, alignment=QtCore.Qt.AlignCenter)
        self.v_main_layout.addLayout(h_final_buttons_layout)
        #
        # v_layout_function_fields = QtWidgets.QVBoxLayout()
        # # self.functions = Function_Gui(self.flag_function_target_type, None, fields_lay=v_layout_function_fields)
        # # self.functions.set_up_widget(v_layout_function_window)
        #
        # h_lay_functions_main.addLayout(v_layout_function_window)
        # h_lay_functions_main.addLayout(v_layout_function_fields)

        # self.buttonBox = QtWidgets.QDialogButtonBox(self)
        # self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
        # self.buttonBox.setStandardButtons(QtWidgets.QDialogButtonBox.Cancel | QtWidgets.QDialogButtonBox.Ok)
        # self.buttonBox.setObjectName("buttonBox")
        # self.v_main_layout.addWidget(self.buttonBox)
        #
        # self.retranslateUi(Dialog)
        # self.buttonBox.accepted.connect(Dialog.accept)
        # self.buttonBox.rejected.connect(Dialog.reject)
        # QtCore.QMetaObject.connectSlotsByName(Dialog)
        if scenes_flag:
            self.area_input.return_target = self.display_data
            if quick_load_scene:
                self.load_scene_to_display(quick_load_scene)
                # print(quick_load_scene.data())
                self.scene_list.select_element(quick_load_scene)

    def done(self):
        if self.display_data:
            check_if_data_remains = self.display_data.get_data()
            if check_if_data_remains:
                qm = QtWidgets.QMessageBox()
                answer = qm.question(None, 'Not done', "Are you sure you are done with scenes?", qm.Yes | qm.No)
                if answer == qm.No:
                    return
        self.close()

    def load_function(self):
        selected_item = self.display_data.selected_element()
        if selected_item:
            if selected_item.parent():
                parent = selected_item.parent()
            elif selected_item.child(0,0):
                parent = selected_item
            else:
                return
            data = []
            """for some reason it works. probably its like that for folders"""
            self.display_data.get_data(parent_index=parent, root_list=data)
            data = data[0]
            f_data = list(data.keys())
            f_data += data[f_data[0]]

            """now fdata is dictionary with key as function title and list of function values"""
            self.functions.display_explanation(function_title=f_data[0])
            self.functions.prepare_function_fields(f_data)

    def prepare_markup_buttons(self):
        v_lay_main = QtWidgets.QVBoxLayout()
        label_chara = SimpleFields.CustomLabel(None, 'CHARACTER')
        label_chara.change_position('C')
        v_lay_main.addWidget(label_chara)

        h_lay_first = QtWidgets.QHBoxLayout()
        self.l_player_name = SimpleFields.SingleList(label_text='testerror', edit=False, field_data={'choices':['Player Name', 'normal', 'shout', 'initials']})
        # self.l_player_name.reload_options(['Player Name', 'normal', 'shout', 'initials'])
        self.l_player_name.currentTextChanged.connect(self.player_name)
        h_lay_first.addWidget(self.l_player_name)

        b_player_money = SimpleFields.CustomButton(None, 'Player Money')
        b_player_money.clicked.connect(lambda: self.area_input.insert_text('{PlayerMoney}'))
        h_lay_first.addWidget(b_player_money)
        b_player_progress = SimpleFields.CustomButton(None, 'Player Progress')
        b_player_progress.clicked.connect(lambda: self.area_input.insert_text('{ProgressDisplay}'))
        h_lay_first.addWidget(b_player_progress)
        h_lay_first.addStretch(1)
        b_player_choice = SimpleFields.CustomButton(None, 'Player Choice')
        b_player_choice.clicked.connect(lambda: self.area_input.insert_text('{DisplayPlayerChoice}'))
        h_lay_first.addWidget(b_player_choice, alignment=QtCore.Qt.AlignRight)
        b_player_orgasm = SimpleFields.CustomButton(None, 'Player Orgasm')
        b_player_orgasm.setToolTip('displays the orgasm line for the player or monster respectively.\n'
                                   ' To be used with OnPlayerOrgasm and OnOrgasm lineTriggers utilizing events respectively. \n'
                                   'If using it in a loop, use the EmptySpiritCounter function after the line \n'
                                   'to empty out how much spirit is counted')
        b_player_orgasm.clicked.connect(lambda: self.area_input.insert_text('{PlayerOrgasmLine}'))
        h_lay_first.addWidget(b_player_orgasm, alignment=QtCore.Qt.AlignRight)
        v_lay_main.addLayout(h_lay_first)

        h_lay_second = QtWidgets.QHBoxLayout()
        self.l_damage_target = SimpleFields.SingleList(edit=False)
        self.l_damage_target.reload_options(['Damage Target', 'player', 'enemy', 'final'])
        self.l_damage_target.currentTextChanged.connect(self.damage_target)
        h_lay_second.addWidget(self.l_damage_target)

        self.l_mark_1 = SimpleFields.SingleList(edit=False)
        self.l_mark_1.reload_options(['Attacker', 'YouOrMonsterName', 'HeOrShe', 'HisOrHer', 'HimOrHer'])
        self.l_mark_1.currentTextChanged.connect(lambda: self.mark(self.l_mark_1))
        h_lay_second.addWidget(self.l_mark_1)
        self.l_mark_2 = SimpleFields.SingleList(edit=False)
        # self.l_mark_2.reload_options(['ATarget', 'YouOrMonsterName', 'HeOrShe', 'HisOrHer', 'HimOrHer'])
        self.l_mark_2.set_val(['Target', 'YouOrMonsterName', 'HeOrShe', 'HisOrHer', 'HimOrHer'], sort=False)
        self.l_mark_2.currentTextChanged.connect(lambda: self.mark(self.l_mark_2))
        h_lay_second.addWidget(self.l_mark_2)
        h_lay_second.addStretch(1)
        b_m_choice = SimpleFields.CustomButton(None, 'Monster Choice')
        b_m_choice.clicked.connect(lambda: self.area_input.insert_text('{DisplayMonsterChoice}'))
        h_lay_second.addWidget(b_m_choice, alignment=QtCore.Qt.AlignRight)
        b_m_orgasm = SimpleFields.CustomButton(None, 'Monster Orgasm')
        b_m_orgasm.clicked.connect(lambda: self.area_input.insert_text('{MonsterOrgasmLine}'))
        h_lay_second.addWidget(b_m_orgasm, alignment=QtCore.Qt.AlignRight)
        v_lay_main.addLayout(h_lay_second)

        """second part"""

        label_text = SimpleFields.CustomLabel(None, 'TEXT')
        label_text.change_position('C')
        v_lay_main.addWidget(label_text)

        h_lay_3 = QtWidgets.QHBoxLayout()


        b_colour_text = SimpleFields.CustomButton(None, 'C TEXT')
        h_lay_3.addWidget(b_colour_text)
        b_colour_example1 = SimpleFields.CustomButton(None, 'EXAMPLE')
        h_lay_3.addWidget(b_colour_example1)
        b_colour_text.clicked.connect(lambda: self.show_color_picker(b_colour_example1))
        b_colour_example1.clicked.connect(lambda: self.colour_text(b_colour_example1))
        b_colour_outline = SimpleFields.CustomButton(None, 'C OUTLINE')
        h_lay_3.addWidget(b_colour_outline)
        b_colour_example2 = SimpleFields.CustomButton(None, 'EXAMPLE')
        h_lay_3.addWidget(b_colour_example2)
        b_colour_outline.clicked.connect(lambda: self.show_color_picker(b_colour_example2))
        b_colour_example2.clicked.connect(lambda: self.colour_text(b_colour_example2))


        b_delay_input = SimpleFields.CustomButton(None, 'Delay until input')
        b_delay_input.setToolTip('will delay the displayed text till user input is given to signal it to continue.\n'
                                 ' It can be given an integer value via {w=int} to make it wait the given\n'
                                 ' integer number in seconds, though it can continue early through user input\n'
                                 ' before the given time has elapsed.')
        b_delay_input.clicked.connect(lambda: self.area_input.insert_text('{w}'))
        h_lay_3.addWidget(b_delay_input)
        b_delay_nline = SimpleFields.CustomButton(None, 'Delay until new line')
        b_delay_nline.setToolTip('same as input but inserts line breaks for every time it is called')
        b_delay_nline.clicked.connect(lambda: self.area_input.insert_text('{}'))
        h_lay_3.addWidget(b_delay_nline)
        b_get_over = SimpleFields.CustomButton(None, 'Get over here')
        b_get_over.setToolTip('placed anywhere in the string causes the displayed text to instantly move towards the markup declaration. \n'
                              'Given MGD by default has all text display instantly, this typically won’t be too useful unless combined with the {cps}')
        b_get_over.clicked.connect(lambda: self.area_input.insert_text('{nw}'))
        h_lay_3.addWidget(b_get_over)
        v_lay_main.addLayout(h_lay_3)

        h_lay_4 = QtWidgets.QHBoxLayout()
        b_text_speed = SimpleFields.CustomButton(None, 'Game text speed')
        b_text_speed.setToolTip('overrides the games default text speed when displaying text, \n'
                                 'standing for characters per second. Useful given the game by default\n'
                                 ' has all text display instantly.')
        b_text_speed.clicked.connect(lambda: self.area_input.insert_text('{nw}'))
        h_lay_4.addWidget(b_text_speed)
        b_after_end = SimpleFields.CustomButton(None, 'Move after End')
        b_after_end.setToolTip('placed anywhere in the string causes the displayed text to automatically\n'
                               'move to the next screen once the final character has been displayed. \n'
                               'Given MGD by default has all text display instantly, this typically\n'
                               'won’t be too useful unless combined with the {cps}.')
        b_after_end.clicked.connect(lambda: self.area_input.insert_text('{}'))
        h_lay_4.addWidget(b_after_end)
        b_remove_after = SimpleFields.CustomButton(None, 'Remove After')
        b_remove_after.setToolTip('exists specifically for technical use with OnPlayerOrgasm,\n'
                                  'ensuring any text in a string after it is called is removed')
        b_remove_after.clicked.connect(lambda: self.area_input.insert_text('|c|'))
        h_lay_4.addWidget(b_remove_after)
        b_split_text = SimpleFields.CustomButton(None, 'Split Text')
        b_split_text.setToolTip('splits the string, causing everything after the |n|, to display on the next screen of'
                                ' text. Useful for long attack descriptions or player orgasm lines')
        b_split_text.clicked.connect(lambda: self.area_input.insert_text('|c|'))
        h_lay_4.addWidget(b_split_text)
        b_vSpace = SimpleFields.CustomButton(None, 'V Space')
        b_vSpace.setToolTip('insert vertical space.')
        b_vSpace.clicked.connect(lambda: self.area_input.insert_text('{vspace=}'))
        h_lay_4.addWidget(b_vSpace)
        b_hSpace = SimpleFields.CustomButton(None, 'V Space')
        b_hSpace.setToolTip('insert horizontal space.')
        b_hSpace.clicked.connect(lambda: self.area_input.insert_text('{space=}'))
        h_lay_4.addWidget(b_hSpace)
        v_lay_main.addLayout(h_lay_4)

        h_lay_5 = QtWidgets.QHBoxLayout()
        b_sex_adjective = SimpleFields.CustomButton(None, 'Sex Adjective')
        b_sex_adjective.setToolTip('gets an adjective from the below bank, Vaginal or Anal based depending on stance.\n'
                                   'Note the space after each word. The empty string means it can roll a blank.\n'
                                   'Sex: [“”, “wet “, “tight “, “wet “, “tight “, “receptive “, “warm “]\n'
                                   'Anal: [“”, “tight “, “tight “, “curved “, “rounded “, “receptive “]')
        b_sex_adjective.clicked.connect(lambda: self.area_input.insert_text('{SexAdjective}'))
        h_lay_5.addWidget(b_sex_adjective)
        b_sex_word = SimpleFields.CustomButton(None, 'Sex Word')
        b_sex_word.setToolTip('gets a sex word from the bank, Vaginal or Anal based depending on stance.\n'
                                                      ' It will pick a string randomly from an array, depending on either sex or anal stance\n'
                                                      'Sex: [“pussy”, “pussy”, “slit”, “honeypot”]\n'
                                                      'Anal: [“ass”, “ass”, “rear”, “behind”, “derriere”]')
        b_sex_word.clicked.connect(lambda: self.area_input.insert_text('{SexWords}'))
        h_lay_5.addWidget(b_sex_word)
        simple_mark_ups = {'(Underline)': {'style': '', 'beg': '{u}', 'end': '{/u}', 'tooltip': ''},
                           '(Italic)': {'style': '', 'beg': '{i}', 'end': '{/i}', 'tooltip': ''},
                           '(Bold)': {'style': 'QPushButton { font-weight: bold; }', 'beg': '{b}', 'end': '{/b}', 'tooltip':''},
                           '(Strike)': {'style': '', 'beg': '{s}', 'end': '{/s}', 'tooltip': ''},
                           '(Plain)': {'style': '', 'beg': '{plain}', 'end': '{/plain}', 'tooltip': ''},
                           '(Size)': {'style': '', 'beg': '{size=}', 'end': '{/size}', 'tooltip':'will make the following text size equal to the given integer value after = in the markup.\n'
                                                      'You can also make it relatively bigger or smaller compared to its previous state based\n'
                                                      ' on the given value through the use of either +int or -int.\n'
                                                      ' You can layer them inside one another, but note {/size} will not end all instances of {size=int}, only one instance at a time.'}}
        last_row_button = []
        for marks in simple_mark_ups:
            # b_simple_markup = SimpleFields.CustomButton(None, marks)
            b_simple_markup = QtWidgets.QPushButton(text=marks)
            if simple_mark_ups[marks]['tooltip']:
                b_simple_markup.setToolTip(simple_mark_ups[marks]['tooltip'])
            if simple_mark_ups[marks]['style']:
                b_simple_markup.setStyleSheet(simple_mark_ups[marks]['style'])
            # b_simple_markup.clicked.connect(lambda: self.area_input.mark_text(marks, simple_mark_ups[marks]['end']))
            # b_simple_markup.clicked.connect(lambda: self.area_input.mark_text(simple_mark_ups[marks]['beg'], simple_mark_ups[marks]['end']))
            h_lay_5.addWidget(b_simple_markup)
            last_row_button.append(b_simple_markup)
        custom_font = last_row_button[3].font()
        custom_font.setStrikeOut(True)
        last_row_button[3].setFont(custom_font)
        custom_font = last_row_button[1].font()
        custom_font.setItalic(True)
        last_row_button[1].setFont(custom_font)
        custom_font = last_row_button[0].font()
        custom_font.setUnderline(True)
        last_row_button[0].setFont(custom_font)

        last_row_button[0].clicked.connect(lambda: self.area_input.mark_text(simple_mark_ups['U']['beg'], simple_mark_ups['U']['end']))
        last_row_button[1].clicked.connect(lambda: self.area_input.mark_text(simple_mark_ups['I']['beg'], simple_mark_ups['I']['end']))
        last_row_button[2].clicked.connect(lambda: self.area_input.mark_text(simple_mark_ups['B']['beg'], simple_mark_ups['B']['end']))
        last_row_button[3].clicked.connect(lambda: self.area_input.mark_text(simple_mark_ups['S']['beg'], simple_mark_ups['S']['end']))
        last_row_button[4].clicked.connect(lambda: self.area_input.mark_text(simple_mark_ups['P']['beg'], simple_mark_ups['P']['end']))
        last_row_button[5].clicked.connect(lambda: self.area_input.mark_text(simple_mark_ups['Size']['beg'], simple_mark_ups['Size']['end']))


        v_lay_main.addLayout(h_lay_5)

        self.mark_up_buttons_background_player.setLayout(v_lay_main)
        return

    def put_text(self, val):
        self.area_input.insert_text(val)

    def show_color_picker(self, field_to_colour):
        # Create a color dialog
        color_dialog = QtWidgets.QColorDialog(self)

        # Get the selected color from the dialog
        color = color_dialog.getColor()

        if color.isValid():
            # Update the button's background color
            field_to_colour.setStyleSheet("background-color: " + color.name() + ";")

    def cancel_scene(self):
        self.area_input.clear_val()
        for field in self.data_fields:
            self.data_fields[field].clear_val()
    def colour_text(self, field_with_colour):
        return
    #     TODO
    def player_name(self, value):
        if value != 'Player Name':
            if value == 'normal':
                self.area_input.insert_text('{ThePlayerName}')
            if value == 'shout':
                self.area_input.insert_text('{THEPLAYERNAME}')
            if value == 'initials':
                self.area_input.insert_text('{TPN}')
        self.l_player_name.setCurrentIndex(0)
        self.area_input.setFocus()
    def damage_target(self, value):
        if value != 'Damage Target':
            if value == 'player':
                self.area_input.insert_text('{DamageToPlayer}')
            if value == 'enemy':
                self.area_input.insert_text('{DamageToEnemy}')
            if value == 'final':
                self.area_input.insert_text('{FinalDamage}')
        self.l_damage_target.setCurrentIndex(0)
        self.area_input.setFocus()
    def mark(self, field):
        if field.currentIndex() > 0:
            self.area_input.insert_text('{'+field.itemText(0)+field.get_val()+'}')
            field.setCurrentIndex(0)

    def display_scene_list(self):
        if self.scene_list.isVisible():
            self.scene_list.hide()
        else:
            self.scene_list.show()
        return

    def change_size(self, param):
        self.adjustSize()
        # value = int(self.text_test.get_val())
        # if param == 1:
        #     self.area_input.setMaximumWidth(value)
        # else:
        #     self.area_input.setMaximumHeight(value)
        # self.area_input.set_val('width - ' + str(self.area_input.size().width()) + ', heigh - ' + str(self.area_input.size().height()))
    # def retranslateUi(self, dialog):
    #     _translate = QtCore.QCoreApplication.translate
    #     dialog.setWindowTitle(_translate("Dialog", "Event Text"))
    def update_row(self):
        selected_item = self.display_data.selected_element()
        # if selected_item.whatsThis() != 'function':
        self.area_input.clear_val()
        self.area_input.set_val(selected_item.text())
        self.area_input.flag_update = True
    def save_data(self):
        """first, check if scene name is defined"""
        # scene_title = self.data_fields[0].get_val()
        scene_title = self.data_fields['NameOfScene'].get_val()
        if not scene_title:
            show_message('Missing scene title', 'Please provide scene title', 'MissMandatory')
            return
        current_selection = self.scene_list.selected_element()
        if not current_selection:
            """if nothing selected. events scenes are 'EventText' while for monsters its 'loss or vistory scene'"""
            show_message('Missing scene type', 'Please select scene type from scene list(top item)', 'MisMandatory')
            return
        scene_data = {}
        """go over display data manually, whatever is nested need to be put top level.
        In the end, scene is a list of values"""
        scene_text = self.display_data.get_data()
        final_text = []
        for text in scene_text:
            if isinstance(text, dict):
                for i in text:
                    final_text.append(i)
                    for ii in text[i]:
                        final_text.append(ii)
            else:
                final_text.append(text)
        for fields in self.data_fields:
            # in case of theScene, getdata gathers it into dictionary, but should be a simple list - "finalText"
            if fields == 'theScene':
                scene_data[fields] = final_text
            else:
                scene_data[fields] = self.data_fields[fields].get_val()
        # scene_data['theScene'] = final_text
        """now, put it in correct plane in scene container. in case of girls scenes, it might be win or lose
        so check what is selected and take its parent"""
        """now, how to save scene in scenelist"""
        insert_row = -1
        if current_selection.parent():
            """selected scene, not scene type, add above"""
            temp = current_selection.parent()
            scene_type = temp.text()
            insert_row = current_selection.row()
        else:
            """if no parent, selected scene type, add to it"""
            scene_type = current_selection.text()
        if scene_title not in list(self.current_scenes[scene_type].keys()):
            """if title already exists, then user is updating, no need to change, otherwise, insert or add new scene"""
            if insert_row > -1:
                """user selected scene, insert new scene above selection"""
                self.scene_list.insert_row([scene_title])
                # self.current_scenes[scene_type].insert(insert_row, scene_data)
            else:
                """user selected parent"""
                self.scene_list.add_data([scene_title], current_selection)
        self.current_scenes[scene_type][scene_title] = scene_data
        # self.display_data.clear_tree()
        for field in self.data_fields:
            self.data_fields[field].clear_val()
    def switch_to_data(self):
        if self.flag_data:
            """if true, hide data and display scenes"""
            self.flag_data = False
            self.display_data.show()
            self.scene_data_widget_background.hide()
            if self.flag_main_data:
                self.functions.treeview_main_game_items.hide()
        else:
            """if false, show data and hide scenes"""
            self.flag_data = True
            self.display_data.hide()
            self.scene_data_widget_background.show()
            if self.flag_main_data:
                self.functions.treeview_main_game_items.show()

    def load_scene_to_display(self, clicked_index=None):
        """user double cliked on scene in scene lookup. if its parent, clear display, if not, load scene"""
        """clear display"""
        self.display_data.clear_tree()
        # item_data = self.scene_list.selected_element()
        item_data = self.scene_list.transform_index_to_item(clicked_index)
        # scene_data = []
        if item_data.parent():
            """if it has parent, user clicked on specific scene. otherwise, there is nothing to load"""
            selected_scene_to_load = item_data.text()
            for scene_type in self.current_scenes:
                """scene type - eventScene, lossScene, VictoryScene"""
                if selected_scene_to_load in list(self.current_scenes[scene_type].keys()):
                    """In theory, I should be able to get scene type for item_data.parent() But this works too"""
                    scene_data = self.current_scenes[scene_type][item_data.text()]
                    for data in scene_data:
                        if data == 'theScene':
                            """now here it should go over all the text and combine functions
                            flag functionazied in temp data is in case user changes scenes several times.
                            instead of going over it again and again, transform it one, and check flag.
                            Although, now that i think about it, MODVAR also keeps it as a simple list.....
                            so probably need to change how it is saved in MODVAR and later when saving to file"""
                            if selected_scene_to_load in SimpleFields.mod_temp_data.mod_data['events'][SimpleFields.mod_temp_data.current_editing_event]['Functionized']:
                                if not SimpleFields.mod_temp_data.mod_data['events'][SimpleFields.mod_temp_data.current_editing_event]['Functionized'][selected_scene_to_load]:
                                    self.functionize(scene_data[data])
                                    SimpleFields.mod_temp_data.mod_data['events'][SimpleFields.mod_temp_data.current_editing_event]['Functionized'][selected_scene_to_load] = 1
                            else:
                                SimpleFields.mod_temp_data.mod_data['events'][
                                    SimpleFields.mod_temp_data.current_editing_event]['Functionized'][
                                    selected_scene_to_load] = 1
                                self.functionize(scene_data[data])
                            self.display_data.add_data(scene_data[data])
                        else:
                            self.data_fields[data].set_val(scene_data[data])
                    break
        else:
            return

    def functionize(self, scene_data=[]):
        """here, go over list of string of scene data, compare each to functions
        if found function, check amount/type of steps and turn it into a dictionary"""
        tagging_no = 0
        verse_idx = 0
        f_end = 'EndLoop'
        while verse_idx < len(scene_data):
            temp = {}
            if tagging_no == 0:
                """first add verse to scene display. Then check if its a functions or not"""
                if scene_data[verse_idx].find(' ') < 0:
                    """if there is no space, it might be a functions. Or it's just a 1 word sentence"""
                    tagging_no = GlobalVariables.Glob_Var.function_steps_no(function_name=scene_data[verse_idx])
                    """if tagging no was returned, then its functions, add tag"""
                    if tagging_no:
                        if isinstance(tagging_no, str):
                            """if its string, then its either endloop or endmusic, so write in off and change to -1
                            there will be issues with some unique functions like AddMonsterToEncounter,
                            which has optional fields and no endloop"""
                            f_end = tagging_no
                            if tagging_no == 'check':
                                tagging_no = 1
                            else:
                                tagging_no = -1
                        f_title = scene_data.pop(verse_idx)  #poping skips laters
                    else:
                        verse_idx += 1
                else:
                    verse_idx += 1
            else:
                temp[f_title] = []
                """if tagging no is greater then 0, then now its attributes to add"""
                if tagging_no > 0:
                    if f_end == 'check':
                        """also, there are some function with optional fields which are not empty, so number of attributes
                        is changing, here will be specialized"""
                        if f_title == 'AddMonsterToEncounter':
                            next_attribute = scene_data[verse_idx]
                            if next_attribute == 'ChangeForm':
                                tagging_no = 2
                            else:
                                tagging_no = 1
                        elif f_title == 'PlayMotionEffectCustom':
                            """ first check if effect is empty
                                "", "Character", "Aiko", "0", "0"
                                "", "Bodypart", "Aiko", "Expression", "0", "0"
                                first check 3 value, if there is a 0, its 4 fields, if not, its 5"""
                            if not scene_data[verse_idx]:
                                next_attribute = scene_data[verse_idx+3]
                                if next_attribute == '0':
                                    tagging_no = 4
                                else:
                                    tagging_no = 5
                            else:
                                """ "Bounce", "Characters", "1.0", "15"
                                    "Ride", "Bodypart", "Aiko", "Expression", "0.5", "10"
                                    first check third value, if there is a dot, there is 1 more, if not
                                    check if value earlier got dot, if not, its 2 more, if yes, its just 4 fields"""
                                next_attribute = scene_data[verse_idx+3]
                                if '.' in next_attribute:
                                    tagging_no = 5
                                else:
                                    prev_attribute = scene_data[verse_idx+2]
                                    if '.' in prev_attribute:
                                        tagging_no = 4
                                    else:
                                        tagging_no = 6
                    while tagging_no > 0:
                        temp[f_title].append(scene_data.pop(verse_idx))
                        tagging_no -= 1
                elif tagging_no < 0:
                    """here is when there is endloop among attributes
                    if tagging is -1 it means endloop is last. is less, then it need to count values after"""
                    tags_verse = f_end
                    while tags_verse:
                        attribute = scene_data.pop(verse_idx)
                        temp[f_title].append(attribute)
                        if attribute == f_end:
                            tags_verse = 'End'
                        if tags_verse == 'End':
                            tagging_no += 1
                        if tagging_no == 0:
                            tags_verse = ''
                scene_data.insert(verse_idx, temp)
                verse_idx += 1

    def test(self):
        temp = self.area_input.textCursor()
        print(temp.selectionStart())
        print(temp.selectionEnd())
        print(temp.selectedText())